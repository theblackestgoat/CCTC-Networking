orkhttps://net.cybbh.io/public/networking/latest/index.html
http://10.50.20.162:8000/
ROCR-002-W

All of the things in one place:
https://miro.com/app/board/o9J_klSqCSY=/

ssh -X student@ 10.50.34.177
X allows for GUI-based programming

1. To view your IP address and interface information:
        a. current =        ip address (ip addr)
        b. deprecated =     ifconfig

    2. To view your ARP cache:
        a. current =        ip neighbor (ip nei)
        b. deprecated =     arp -a

    3. To view open TCP and UDP sockets:
        a. current = 
            i. TCP =        ss -antlp
            ii. UDP =       ss -anulp
        b. deprecated =     netstat

    4. To view active processes:
        a. static =         ps -elf
        b. real-time =      top or htop

    5. To open file manager from the command line or X11 connection:
        a. nautilus
        b. pcmanfm

    6. Web Browsers:
        a. Firefox
        b. Chromium
        c. Konqueror

    7. To open images from the command line or X11 connection:
        a. Eye of Gnome =                   eog [file]
        b. Nomacs =                         nomacs [file]
        c. Eye of Mate =                    eom [file]
        d. GNU Image Manipulation Program = gimp [file]

    8. Network scanning:
        a. nmap
            -sT = TCP Full connection
            -sS = TCP SYN scanning
            -Pn = Disable ping sweep
            -sU = UDP scanning
        b. zenmap
        c. netcat
            TCP: nc -nzvw1 10.10.0.40 21-23 80
            UDP: nc -unzvw1 10.10.0.40 53 69
        d. ping
        e. traceroute

    9. Network Utilization:
        a. iftop
        b. iptraf-ng

    10. Packet Manipulation (requires root privileges):
        a. scapy
        b. hping3
        c. yersinia     yersinia -G

    11. Packet Sniffing (requires root privileges):
        a. Wireshark
        b. tcpdump
        c. p0f
        d. tshark

    12. Banner Grabbing:
        a. netcat
            Client: nc 10.10.0.40 22
            Listener: nc -lvp 1234
        b. telnet
            telnet 10.10.0.40
        c. wget
            wget -r http://10.10.0.40
            wget -r ftp://10.10.0.40
        d. curl
            curl http://10.10.0.40
            curl ftp://10.10.0.40

    13. DNS Query:
        a. whois
        b. dig
            Records:
                A - IPv4
                AAAA - IPv6
                NS - Name Server
                SOA - Start of Authority
                MX - Mail Server
                TXT - Human readable message

    14. Remote access:
        a. ssh
            ssh student@10.10.0.40
            ssh student@10.10.0.40 -p 2222
        b. telnet
            telnet 10.10.0.40
            telnet 10.10.0.40 23

    15. File Transfer:
        a. scp
            scp student@10.10.0.40:file .
            scp file student@10.10.0.40Host Discovery: 

Nmap Scan: 
nmap -sn <ip_range_>/24 

ARP Scan: 
Works if on the same subnethttps://miro.com/app/board/o9J_klSqCSY=/
sudo nmap - PR -sn <targetIP> 

ARP-Scan: 
sudo arp-scan  --localnet 
sudo arp-scan -I eth0 -l 

Ping Scan: 
nmap -PE -sn <targetIP/24> 

TCP SYN Ping: 
sudo nmap -PS -sn <targetIP/24> 

TCP ACK Ping: 
sudo nmap -PA -sn <targetIP/24> 

UDP Ping:  
sudo nmap -PU -sn <targetIP/24> 

MassScan: 
masscan MACHINE_IP/24 -p443 
masscan MACHINE_IP/24 -p80,443 
masscan MACHINE_IP/24 -p22-25 
masscan MACHINE_IP/24 ‐‐top-ports 100 

NetDiscover: 
netdiscover -r <IP_RANGE>/24     ---> Returns MACs, Hostnames :
        b. netcat
            nc 10.10.0.40 1234 < file
            nc -lvp 1234 > file

Host Discovery: 
Nmap Scan: 
nmap -sn <ip_range_>/24 

ARP Scan: 
Works if on the same subnet 
sudo nmap - PR -sn <targetIP> 

ARP-Scan: 
sudo arp-scan  --localnet 
sudo arp-scan -I eth0 -l 

Ping Scan: 
nmap -PE -sn <targetIP/24> 

TCP SYN Ping: 
sudo nmap -PS -sn <targetIP/24> 

TCP ACK Ping: 
sudo nmap -PA -sn <targetIP/24> 

UDP Ping:  
sudo nmap -PU -sn <targetIP/24> 

MassScan: 
masscan MACHINE_IP/24 -p443 
masscan MACHINE_IP/24 -p80,443 
masscan MACHINE_IP/24 -p22-25 
masscan MACHINE_IP/24 ‐‐top-ports 100 
NetDiscover: 
netdiscover -r <IP_RANGE>/24     ---> Returns MACs, Hostnames 

CTF Scans: 
TCP: 
sudo nmap -p- -A -vv 10.10.220.206 -oN ~/TCP_recon.nmap -T4 --min-rate 1000 --max-retries 3 
UDP:  
sudo nmap -p- -sU -vv <targetIP> -oN ~/UDP_recon.nmap -T4 --min-rate 1000 --max-retries 3 

Basic Port Scans 
Port Scan Type Example Command 
TCP Connect Scan nmap -sT 10.10.149.197 
TCP SYN Scan sudo nmap -sS 10.10.149.197 
UDP Scan sudo nmap -sU 10.10.149.197 

Option Purpose 
-p- all ports 
-p1-1023 scan ports 1 to 1023 
-F 100 most common ports 
-r scan ports in consecutive order 
-T<0-5> -T0 being the slowest and T5 the fastest 
--max-rate 50 rate <= 50 packets/sec 
--min-rate 15 rate >= 15 packets/sec 
--min-parallelism 100 at least 100 probes in parallel 
Option Meaning 
-sV determine service/version info on open ports 
-sV --version-light try the most likely probes (2) 
-sV --version-all try all available probes (9) 
-O detect OS 
--traceroute run traceroute to target 
--script=SCRIPTS Nmap scripts to run 
-sC or --script=default run default scripts 
-A equivalent to -sV -O -sC --traceroute 
-oN save output in normal format 
-oG save output in grepable format 
-oX save output in XML format 
-oA save output in normal, XML and Grepable formats 
-oS save output in Script Kiddie format 

Netbios Scan Techniques: 
nmap -p netbios*,microsoft-ds [target host] 
sudo nmap -sU -sS -p U:137-139,T:137-139,445 [target host] 
sudo nmap -sU -sS -p netbios*,microsoft-ds [target host] 

Advanced Port Scans 
Port Scan Type Example Command 
TCP Null Scan sudo nmap -sN 10.10.90.13 
TCP FIN Scan sudo nmap -sF 10.10.90.13 
TCP Xmas Scan sudo nmap -sX 10.10.90.13 
TCP Maimon Scan sudo nmap -sM 10.10.90.13 
TCP ACK Scan sudo nmap -sA 10.10.90.13 
TCP Window Scan sudo nmap -sW 10.10.90.13 
Custom TCP Scan sudo nmap --scanflags URGACKPSHRSTSYNFIN 10.10.90.13 
Spoofed Source IP sudo nmap -S SPOOFED_IP 10.10.90.13 
Spoofed MAC Address --spoof-mac SPOOFED_MAC 
Decoy Scan nmap -D DECOY_IP,ME 10.10.90.13 
Idle (Zombie) Scan sudo nmap -sI ZOMBIE_IP 10.10.90.13 
Fragment IP data into 8 bytes -f 
Fragment IP data into 16 bytes -ff 

Option Purpose 
--source-port PORT_NUM specify source port number 
--data-length NUM append random data to reach given length 
--reason explains how Nmap made its conclusion 
-v verbose 
-vv very verbose 
-d debugging 
-dd more details for debugging 

netstat
ss -antl

# once you have ssh into the INTERNET_HOST box:
$ terminator
$ pcmanfm
  opens a gui to navigate the file structure

1. ARP Storm. What MAC address is initiating the ARP Storm?
ws filter: arp
look for a mac blasting out a bunch of arp requests
Answer: 00:07:0d:af:f4:54

2. ARP – 1. What is the MAC of 10.10.10.1?
ws filter: ip.addr == 10.10.10.1
look at the source to find the mac
Answer:  00:1d:09:f0:92:ab

3. ARP – 2. What is the MAC of 10.10.10.2?
ws filter: ip.addr == 10.10.10.2
look at the source to find the mac
Answer: 00:1a:6b:6c:0c:cc

4. ARP – 3. What is the MAC address of the system trying to perform the ARP MitM attack?
ws filter: arp
fa:16:3e:35:21:5a is claiming multiple ip addresses
Answer: fa:16:3e:35:21:5a

5. RARP – 1. What is the OP code of a RARP Request?
https://www.iana.org/assignments/arp-parameters/arp-parameters.xhtml#arp-parameters-1
Answer: 3

6. RARP – 2. What is the OP code of a RARP Response?
Answer: 4

7. RARP – 3. What is the RARP requestor’s MAC?
Answer: 00:0c:29:34:0b:de

8. RARP – 4. What was the RARP requestor’s resolved IP address?
Answer: 10.1.1.100

9. Gratuitous ARP – 1. What is the MAC of the system spamming gratuitous ARP’s for 192.168.1.254?
look for gratuitous arp requests in info
Answer: 00:00:5e:00:01:01

10. CDP – 1. What is the software version of the Cisco Switch (copy entire field “as is” from Wireshark)?
ws filter: cdp
Answer: IOS (tm) C2950 Software (C2950-I6K2L2Q4-M), Version 12.1(22)EA14, RELEASE SOFTWARE (fc1)

11. CDP – 2. What is the software version of the Cisco Router (copy entire field “as is” from Wireshark)?
ws filter: cdp
Answer: IOS (tm) 1600 Software (C1600-NY-L), Version 11.2(12)P, RELEASE SOFTWARE (fc1)

12. LLDP – 1. What is the System Name of one of the LLDP sending devices?
ws filter: lldp
answer: S1.cisco.com

13. STP – 1. What is the Bridge Priority of the STP Root Bridge?
ws filter: stp
look in spanning tree protocol dropdown
Answer: 0

14. STP – 2. What is the MAC address of the STP Root Bridge?
Answer: 00:1f:27:b4:7d:80

15. VTP – 1. What is the VTP Management Domain Name?
Answer: cicso

16. VTP – 2. What is the latest configuration revision number?
Answer: 11

17. VTP – 3. How many total VLANs are being advertised via VTP?
Answer: 22

18. VLAN – 1. What is the message contained within the single tagged VLAN traffic coming from 11.22.33.44?
filter for the ip and follow tcp stream
Answer: I pitty the foo

19. VLAN – 2. What is the VLAN ID of this traffic?
Answer: 999

20. VLAN Hopping – 1. What is the VLAN ID being attacked by 10.10.10.10 using Double Tagging?
250

21. VLAN Hopping – 2. What is the combined message being sent via ICMP?
Answer: Wouldn't you like too be a Pepper Too!

22. ICMP – 1. What is the OS of 192.168.1.1 host based off its Echo Request message to the Google DNS?
TTL = 64
Answer: linux

23. ICMP – 2. What is the message that 192.168.65.20 sending to Google's DNS via ICMP?
Answer: Exsqueeze me?

24. ICMP – 3. How many Hops away is the 151.101.64.84 address?
Answer: 11

25. Fragmented – 1. What is the IP ID of the fragmented ICMP packet? (starting at packet 6472)
Answer: 46544

26. Fragmented – 2. What is the offset value of the fragments?
    Not the calculated value shown in Wireshark
    Suggest converting the value from the Hex Dump
Answer: 122

27. Fragmented – 3. What is the possible OS of the system that sent this ICMP based on the message payload?
Answer: windows

28. ICMPv6 – 1. What is the ICMPv6 type number of Echo Request?
Answer: 128

29. ICMPv6 – 2. What is the ICMPv6 type number of Echo Reply?
Answer: 129

30. ICMPv6 – 3. What is the ICMPv6 type number of the Router Advertisement message?
134

31. ICMPv6 – 4. What is the link-layer address of the advertising router?
Answer: fa:16:3e:35:21:5a

32. ICMPv6 – 5. What is the IPv6 prefix being advertised?
Answer: beef:4:f00d::

33. HSRP – 1. What is the HSRP virtual IP?
Answer: 192.168.0.1

34. HSRP – 2. What is the HSRP multicast address used?
Answer: 224.0.0.2

35. HSRP – 3. What is the IP address of the HSRP Active forwarder (before the takeover)?
Answer: 192.168.0.30

36. HSRP – 4. What is the IP address of the HSRP Active forwarder (after the takeover)?
Answer: 192.168.0.10

37. VRRP – 1. What is the VRRP multicast address used?
Answer: 224.0.0.18

38. VRRP – 2. What is the VRRP virtual IP?
Answer: 192.168.1.254

39. VRRP – 3. How many total devices are communicating via VRRP?
Answer: 3

40. RIP – 1. How many networks are being advertised via RIP?
Answer: 2

41. RIP – 2. What are the networks being advertised (in numeric order separated by commas and no spaces)?
(i.e. 1.0.0.0,2.0.0.0 )
Answer: 200.0.1.0,200.0.2.0

42. RIP – 3. What Protocol and port is being used for RIP?
Transport PROTOCOL PORT
Answer: UDP 520

43. EIGRPv4 – 1. What network is being advertised via EIGRPv4
Answer: 192.168.4.0/24

44. EIGRPv4 – 2. What is the IP protocol number used for EIGRP?
Answer: 88

45. EIGRPv4 – 3. What multicast address is used to send EIGRPv4 updates?
Answer: 224.0.0.10

46. EIGRPv6 – 1. What network is being advertised via EIGRPv6
Answer: 2001:db8:0:400::/64

47. EIGRPv6 – 2. What multicast address is used to send EIGRPv6 updates?
Answer: ff02::a

48. EIGRPv6 – 3. What Autonomous system number is being used?
Answer: 100

49. OSPF – 1. What is the IP protocol number used for OSPF?
Answer: 89

50. OSPF – 2. What is the IP address of the OSPF designated router (DR)?
Answer: 192.168.170.8

51. OSPF – 3. What multicast address is used by the DR to send updates?
Answer: 224.0.0.5

52. BGP – 1. How many networks are being advertised via BGP?

54. BGP – 3. What Autonomous system number is the 192.168.0.10 peer in?
Answer: 62510 

55. BGP – 4. What Protocol and port is being used for BGP?
Transport PROTOCOL PORT
Answer: TCP 179

52. BGP – 1. How many networks are being advertised via BGP?
Answer: 3

53. BGP – 2. What are the networks being advertised (in numeric order separated by commas and no spaces)?
(i.e. 1.0.0.0,2.0.0.0)
Answer: 10.0.0.0/8,172.16.0.0/16,192.168.4.0/22

Wh@t_P@load?

1. SMB – 1. What Protocol and port is being used for SMB?
PROTOCOL PORT
Answer: TCP 445

2. SMB – 2. What is the name of the file accessed via SMB?
    Follow the stream
Answer: putty.exe

3. DHCP – 1. What is the IP address of the DHCP server?
ws filter: bootp
Answer: 192.168.0.1

4. DHCP – 2. What is the “offered” IP address?
Answer: 192.168.0.10

5. DHCP – 3. What is the DHCP lease time (in seconds)?
Answer: 3600

6. DNS – 1. What ".com" webpage was the “A” record requested for?
Answer: microsoft.com

7. DNS – 2. What webpage was the “AAAA” record requested for?
Answer: wikipedia.org

8. DNS – 3. What mail server was the “MX” record requested for?
Answer: hotmail.com

9. DNS – 4. What domain was the Zone transfer requested for?
Answer: etas.com

10. FTP – 1. What is the username/password used for the FTP authentication?
Answer: student10/password10

11. FTP – 2. What was the filename requested via FTP?
Answer: DO_NOT_LOOK.txt

12. FTP – 3. What was the message in the file transferred via FTP?
Answer: Schrodinger's Cat

13. FTP – 4. What was the source and destination ports used for the Passive FTP (SPORT:DPORT)?
Answer: 42452:38591

14. HTTP – 1. What was the HTTP site reached (without any errors or redirects)?
Answer: www.faqs.org

15. HTTP – 2. What was the HTTP site that was “Moved Temporarily”?
Answer: https://snippets.cdn.mozilla.net/us-west/bundles/bundle_6fdbf7e26c281d58ce9687293f922ec1607595bb.json

16. HTTP – 3. What was the HTTP site that was “Moved Permanently”?
Answer: http://msn.com/

17. HTTP – 4. What was the HTTPs (TLS) site that was reached?
Answer: twitter.com

18. SMTP – 1. What is the SMTP domain name?
(i.e. domain.com )
Answer: virginmedia.com

19. SMTP – 2. Who sent the email to (cuizw@public.qd.sd.cn)?
Answer: owadomyi2897@virginmedia.com

20. SMTP – 3. From the message, what are “self-explanatory”?
Answer: sizes

21. SMTP – 4. What is the name of the SMTP server communicating over IPv6?
Answer: mx.google.com

22. IMAP – 1. What is the username that signed-in via IMAP?
Answer: LOGIN "neulingern" "XXXXXX"

23. IMAP – 2. How many emails were “fetched”?
Answer: Jerry Hammons

25. POP – 1. What is the POP mailbox address?
Answer: digitalinvestigator@networksims.com

26. POP – 2. How many messages does this mailbox have?
Answer: 3

27. POP – 3. What is the name of the University in one of the email messages?
Answer: Edinburgh Napier University

28. NTP – 1. What is the IP of the NTP server?
Answer: 192.168.50.50

29. NTP – 2. What is the Timestamp in the NTP messages (MONTH DAY, YEAR)?
Answer: Sep 27, 2004 03:18:04.922896299 UTC

30. NTP – 3. What is the NTP version number?
Answer: 3

31. SSH – 1. What is the SSH server IP address?
Answer: 172.16.40.10

32. SSH – 2. What is the SSH protocol version being used by both (copy entire field “as is” from Wireshark)?
Answer: SSH-2.0-OpenSSH_7.9p1 Debian-10+deb10u2

33. SSH – 3. Which asymmetric encryption protocol is being used?
Answer: diffie-hellman

34. SSH – 4. What is the MSS option set to for the SSH communication?
    MSS can be found in the SYN exchange.
Answer: 1410

35. SSH – 5. What is the windows scale shift option set to?
    Windows scale can be found in the SYN exchange.
Answer: 7

36. TELNET – 1. What is the username/password of the account used via telnet?
Answer: fake/user

37. TELNET – 2. What is the exact first command issued on the remote system over telnet?
Answer: /sbin/ping www.yahoo.com

38. TELNET – 3. What was the second command issued?
Answer: ls

39. TELNET – 4. What is the inital sequence number of the client?
    suggest to convert the Hexdump to Decimal
Answer: 2579865836

40. TELNET – 5. What is the MSS of the server?
Answer: 1448

41. RADIUS – 1. What was the username used to log in via RADIUS
Answer: John.McGuirk

42. RADIUS – 2. What is the RADIUS Request code?
Answer: 1

43. RADIUS – 3. What is the RADIUS Accept code?
Answer: 2

44. RADIUS – 4. What is the RADIUS Challenge code?
Answer: 11

45. TACACS+ – 1. What is the IP of the TACACS+ server?
Answer: 192.168.1.5

46. TACACS+ – 2. What is the SPORT used for the communication?
Answer: 59087

47. TACACS+ – 3. What is the MSS option set to for the TACACS+ communication?
Answer: 1460

48. TACACS+ – 4. What is the starting window size of the TACACS+ client?
Answer: 4128

49. SNMP – 1. What SNMP version is being used?
Answer: 3

50. SNMP – 2. What is the IPv4 address of the SNMP server?
    It will be the system doing the get-request
Answer: 10.0.0.150

51. SNMP – 3. What is the IPv6 address of the SNMP server?
    It will be the system doing the get-request
Answer:2001:470:e5bf:1001:1cc7:73ff:65f5:a2f7

52. SNMP – 4. What Protocol and port is being used for SNMP communication?
PROTOCOL PORT
Answer: UDP 161

53. TFTP – 1. What is the IP address of the TFTP server?
Answer: 192.168.0.13

54. TFTP – 2. What is the name of the file uploaded to the TFTP server?
Answer: rfc1350.txt

55. TFTP – 3. How many TFTP “Blocks” were used to send the file?
Answer: 49

TCPDUMP
sudo tcpdump -i eth0 -XXvnn -w file.pcap
sudo tcpdump -r file.pcap

N3tw0rkBPF

Basic Analysis - ttl. What is the Berkeley Packet Filter, using tcpdump, to capture all packets with a ttl of 64 and less, utilizing the IPv4 or IPv6 Headers? There should be 8508 packets.
Enter the Filter syntax with no spaces
$ sudo tcpdump 'ip[8] <= 64 || ip6[7] <= 64' -r BPFCheck.pcap | wc -l
ip[8] refers to the TTL field within the IPv4 header. The TTL field is located at byte offset 8 in the IP header.
ip6[7] refers to the Hop Limit field within the IPv6 header. The Hop Limit field is located at byte offset 7 in the IPv6 header.
The expression <= 64 checks if the TTL or Hop Limit is less than or equal to 64, which matches packets with a TTL value of 64 and lower.
Answer: ip[8]<=64||ip6[7]<=64

Basic Analysis - dont fragment. What is the Berkeley Packet Filter, using tcpdump, to capture all IPv4 packets with at least the Dont Fragment bit set? There should be 2321 packets.
tcpdump -i <interface> 'ip[6] & 0x4000 != 0'
Let's break down the filter expression:
ip[6] refers to the 7th byte (offset 6) in the IPv4 header, which contains the "Flags" field.
& 0x4000 performs a bitwise AND operation with the value 0x4000, which corresponds to the DF bit.
!= 0 checks if the result of the bitwise AND operation is not equal to 0, indicating that the DF bit is set.
sudo tcpdump 'ip[6] & 0x40 != 0' -r BPFCheck.pcap | wc -l
Answer: ip[6]&0x40!=0

Basic Analysis - high port. What is the Berkeley Packet Filter, using tcpdump, to capture traffic with a Source Port higher than 1024, utilizing the correct Transport Layer Headers? There should be 7805 packets.
tcpdump -i <interface> '((tcp[0:2] > 1024) or (udp[0:2] > 1024))'
tcp[0:2] represents the first two bytes of the TCP header, which include the source port field.
udp[0:2] represents the first two bytes of the UDP header, which also include the source port field.
> is the greater-than operator.
1024 is the value representing the port number threshold
sudo tcpdump '((tcp[0:2] > 1024) || (udp[0:2] > 1024))' -r BPFCheck.pcap | wc -l
Answer: tcp[0:2]>1024||udp[0:2]>1024

Basic Analysis - udp. What is the Berkeley Packet Filter, using tcpdump, to capture all Packets with UDP protocol being set, utilizing the IPv4 or IPv6 Headers? There should be 1277 packets.
sudo tcpdump 'udp' -r BPFCheck.pcap | wc -l (while this works, it doesn't specify which bit/byte to use to reference "protocol"
sudo tcpdump 'ip[9] = 17 || ip6[6] = 17' -r BPFCheck.pcap | wc -l
For IPv4:
ip[9] refers to the 10th byte (offset 9) in the IPv4 header, which contains the "Protocol" field.
= 17 checks if the value of the "Protocol" field is equal to 17, which corresponds to the UDP protocol.
For IPv6:
ip6[6] refers to the 7th byte (offset 6) in the IPv6 header, which contains the "Next Header" field.
= 17 checks if the value of the "Next Header" field is equal to 17, which corresponds to the UDP protocol.
Answer: ip[9]=17||ip6[6]=17

Basic Analysis - tcp flags. What is the Berkeley Packet Filter, using tcpdump, to capture only packets with the ACK/RST or ACK/FIN flag set, utilizing the correct Transport Layer Header? There should be 1201 packets.
tcpdump -i <interface> 'tcp[13] & 0x15 != 0'
Let's break down the filter expression:
tcp[13] refers to the 14th byte (offset 13) in the TCP header, which contains the TCP flags field.
& 0x15 performs a bitwise AND operation with the value 0x15, which corresponds to the combination of the ACK and RST or ACK and FIN flags.
!= 0 checks if the result of the bitwise AND operation is not equal to 0, indicating that either the ACK/RST or ACK/FIN flags are set.
sudo tcpdump 'tcp[13]=20||tcp[13]=17' -r BPFCheck.pcap | wc -l
Answer: tcp[13]=20||tcp[13]=17

Basic Analysis - id. What is the Berkeley Packet Filter, using tcpdump, to capture all packets with an IP ID field of 213? There should be 10 packets.
sudo tcpdump 'ip[4:2] = 213' -r BPFCheck.pcap | wc -l 
ip[4:2] refers to bytes 5 and 6 (offset 4 to 5) in the IP header, which contain the IP ID field.
= 213 checks if the value of the IP ID field is equal to 213.
Answer" ip[4:2]=213

Basic Analysis - vlan. What is the Berkeley Packet Filter, using tcpdump, to capture all traffic that contains a VLAN tag? There should be 182 packets.
sudo tcpdump 'vlan' -r BPFCheck.pcap | wc -l (this works but isn't the right answer)
sudo tcpdump 'ether proto 0x8100' -r BPFCheck.pcap | wc -l (this also works but isn't the right answer)
ether proto 0x8100 specifies the Ethernet protocol field (EtherType) as 0x8100, which indicates the presence of a VLAN tag using the 802.1Q frame format.
sudo tcpdump 'ether[12:2] = 0x8100' -r BPFCheck.pcap | wc -l
ether[12:2] refers to bytes 13 and 14 (offset 12 to 13) in the Ethernet header, which contain the EtherType field.
= 0x8100 checks if the value of the EtherType field is equal to 0x8100, which indicates the presence of a VLAN tag using the 802.1Q frame format.
Answer: ether[12:2]=0x8100

Basic Analysis - dns. What is the Berkeley Packet Filter, using tcpdump, to capture all IPv4 packets relating to DNS? There should be 63 packets.
sudo tcpdump 'tcp[2:2]=53||tcp[0:2]=53||udp[2:2]=53||udp[0:2]=53' -r BPFCheck.pcap | wc -l 
Answer: tcp[2:2]=53||tcp[0:2]=53||udp[2:2]=53||udp[0:2]=53

Basic Analysis - CLIENT CONNECTIONS. What is the Berkeley Packet Filter, using tcpdump, to capture the initial packets from a client trying to initiate a TCP connection? There should be 3447 packets
tcpdump -i <interface> 'tcp[13] & 2 != 0 and tcp[13] & 16 = 0' (this does not give the right answer)
tcp[13] & 2 != 0 checks if the 14th byte (offset 13) in the TCP header has the second bit (SYN flag) set. This filters for packets that contain the SYN flag, indicating a request to establish a TCP connection.
tcp[13] & 16 = 0 checks if the 14th byte (offset 13) in the TCP header has the fifth bit (ACK flag) unset. This filters for packets where the ACK flag is not set, indicating the initial packet of the TCP handshake.
Answer: sudo tcpdump 'tcp[13]=2' -r BPFCheck.pcap | wc -l

Basic Analysis - OPEN PORTS. What is the Berkeley Packet Filter, using tcpdump, to capture the response packets from a server listening on an open TCP ports? There should be 277 packets
tcpdump -i <interface> 'tcp[13] & 2 = 2 and tcp[13] & 18 = 18'
tcp[13] & 2 = 2 checks if the 14th byte (offset 13) in the TCP header has the second bit (SYN flag) set. This filters for packets that have the SYN flag turned on.
tcp[13] & 18 = 18 checks if the 14th byte (offset 13) in the TCP header has both the second bit (SYN flag) and the fourth bit (ACK flag) set. This filters for packets that have both the SYN and SYN+ACK flags turned on.
Answer: tcp[13]=18

Basic Analysis - CLOSED PORTS. What is the Berkeley Packet Filter, using tcpdump, to capture the response packets from a server with closed TCP ports There should be 17 packets
Answer: tcp[13]=4

Basic Analysis - WELL KNOWN PORTS.What is the Berkeley Packet Filter, using tcpdump, to capture all TCP and UDP packets sent to the well known ports? There should be 3678 packets
sudo tcpdump 'tcp[2:2]<=1023||udp[2:2]<=1023' -r BPFCheck.pcap | wc -l  
Answer: tcp[2:2]<=1023||udp[2:2]<=1023

Basic Analysis - HTTP. What is the Berkeley Packet Filter, using tcpdump, to capture all HTTP traffic? There should be 1404 packets
sudo tcpdump 'tcp[2:2]=80||tcp[0:2]=80' -r BPFCheck.pcap | wc -l 
Answer: tcp[2:2]=80||tcp[0:2]=80

Basic Analysis - TELNET. What is the Berkeley Packet Filter, using tcpdump, to capture all telnet traffic? There should be 62 packets
sudo tcpdump 'tcp[2:2]=23||tcp[0:2]=23' -r BPFCheck.pcap | wc -l
Answer: tcp[2:2]=23||tcp[0:2]=23

Basic Analysis - ARP. What is the Berkeley Packet Filter, using tcpdump, to capture all ARP traffic? There should be 40 packets
sudo tcpdump 'arp' -r BPFCheck.pcap | wc -l  (this works but is not the right answer)
sudo tcpdump 'ether[12:2] = 0x0806' -r BPFCheck.pcap | wc -l
Answer: ether[12:2]=0x0806

Basic Analysis - TOTAL CHAOS. What is the Berkeley Packet Filter, using tcpdump, to capture any packets containing the CHAOS protocol within an IPv4 header? There should be 139 packets
Need to figure out which protocol number CHAOS uses:
https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml#J_Noel_Chiappa
CHAOS = 16
sudo tcpdump 'ip[9] = 16' -r BPFCheck.pcap | wc -l
Answer: ip[9]=16

Basic Analysis - dscp. What is the Berkeley Packet Filter, using tcpdump, to capture all IPv4 packets with the DSCP field of 37? There should be 42 packets.
sudo tcpdump 'ip[1] >> 2 = 37'
ip[1] refers to the second byte (offset 1) in the IPv4 header, which contains the Type of Service (ToS) field that includes the DSCP bits.
>> 2 performs a right shift by 2 bits, which effectively discards the first 2 bits (precedence bits) of the ToS field, leaving only the DSCP bits.
= 37 checks if the resulting value is equal to 37, indicating that the DSCP field is set to 37.
Answer: ip[1]>>2=37

Basic Analysis - traceroute. What is the Berkeley Packet Filter, using tcpdump, to capture all IPv4 packets targeting just the beginning of potential traceroutes as it's entering your network. This can be from a Windows or Linux machine using their default settings? There should be 83 packets.
sudo tcpdump '(udp||icmp[0]=8)&&ip[8]=1' -r BPFCheck.pcap | wc -l (this works but doesn't count as correct)
ip[8] = 1 checks if the TTL field in the IP header is equal to 1.
(icmp[0] = 8 and ip[8] = 1) checks if the ICMP type field is equal to 8 (ICMP Echo Request) and the TTL field in the IP header is equal to 1.
udp captures all UDP packets.
(udp||icmp[0]=8)&&ip[8]=1
sudo tcpdump '(ip[9]=17||icmp[0]=8)&&ip[8]=1' -r BPFCheck.pcap | wc -l
sudo tcpdump '(ip[8]=1&ip[9]=1)||(ip[8]=1&ip[9]=17)' -r BPFCheck.pcap | wc -l
ip[9] refers to the tenth byte (offset 9) in the IP header, which contains the Protocol field.
= 17 checks if the Protocol field is equal to 17, which is the assigned value for UDP.
Answer: ????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????

Basic Analysis - URGent EXFIL. What is the Berkeley Packet Filter, using tcpdump, to capture all packets where the URG flag is not set and URG pointer has a value? There should be 43 packets
sudo tcpdump 'tcp[13] & 32 = 0 and tcp[18:2] != 0' -r BPFCheck.pcap | wc -l
tcp[13] refers to the fourteenth byte (offset 13) in the TCP header, which contains the TCP flags field.
& 32 performs a bitwise AND operation with the value 32 (binary 00100000) to check if the URG flag is not set. If the result is zero, it means the URG flag is not set.
tcp[18:2] refers to the nineteenth and twentieth bytes (offset 18 to 19) in the TCP header, which contain the URG pointer field.
!= 0 checks if the URG pointer field has a non-zero value.
Answer: tcp[13]&32=0&&tcp[18:2]!=0

Basic Analysis - NULL SCAN. What is the Berkeley Packet Filter, using tcpdump, to capture a TCP null scan to the host 10.10.10.10? There should be 19 packets
sudo tcpdump 'tcp[13] & 63 = 0 and dst host 10.10.10.10' -r BPFCheck.pcap | wc -l
tcp[13] refers to the fourteenth byte (offset 13) in the TCP header, which contains the TCP flags field.
& 63 performs a bitwise AND operation with the value 63 (binary 00111111) to check if no TCP flags are set. If the result is zero, it means no TCP flags are set, indicating a null scan.
dst host 10.10.10.10 specifies the destination IP address as 10.10.10.10.
sudo tcpdump 'tcp[13] & 63 = 0 and ip[16:4] = 0x0a0a0a0a' -r BPFCheck.pcap | wc -l (also works but this is wrong)
Answer: tcp[13]=0&&ip[16:4]=0x0a0a0a0a 

Basic Analysis - VLAN HOPPING. What is the Berkeley Packet Filter, using tcpdump, to capture an attacker using vlan hopping to move from vlan 1 to vlan 10? There should be 15 packets
ether[14:2] = 0x810a and (vlan or (ether[16:2] = 0x0001 and ether[18:2] = 0x000a))
ether[14:2] = 0x810a checks if the EtherType field of the Ethernet header is 0x810a, which represents a VLAN-tagged frame.
vlan checks for packets with VLAN tags.
(ether[16:2] = 0x0001 and ether[18:2] = 0x000a) checks if the source VLAN ID is 1 and the destination VLAN ID is 10.
sudo tcpdump 'ether[14:2] = 0x8100 and vlan and ether[18:2] = 0x8100
ether[14:2] = 0x8100 checks if the EtherType field of the Ethernet header is 0x8100, indicating the presence of the first VLAN tag.
vlan checks for packets with at least one VLAN tag.
ether[18:2] = 0x8100 checks if the EtherType field at an offset of 18 bytes in the Ethernet header is 0x8100, indicating the presence of the second VLAN tag.
20:22:48.381359 IP 192.168.0.1 > 255.255.255.255: ICMP echo request, id 0, seq 0, length 8 <-- this is definitely one of the packets that we want


Packet Crafting and Socket Creation
start flag: raw_packet_start

Senders:
DGRAM.py
#!/usr/bin/python3
import socket
s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, 0)
ip_addr = '127.0.0.1'
port = 4321
# Connect to a remote socket at address.
# s.connect((ip_addr, port)) # typically used for TCP
message = b"CCTC"
#Send data to the socket. The socket should not be connected to a remote socket. Typically used for UDP.
s.sendto (message, (ip_addr, port))
#Receive data from the socket. The return value is a pair (bytes, address) where bytes is a bytes object representing the data received$
data, addr = s.recvfrom(1024)
# You can optionally use s.recv but it will only return (bytes)
#Default encoding is 'utf-8'. errors may be given to set a different error handling scheme. The default for errors is 'strict', meaning$
print(data.decode())
# using "utf-8" default

RAW.py
#!/usr/bin/python3
# For building the socket
import socket
# For system level commands
import sys
# For establishing the packet structure (Used later on), this will allow direct access to the methods and functions in the struct module
from struct import *
# For encoding
import base64               # base64 module
import binascii            # binascii module
# Create a raw socket.
try:
    s = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_RAW)
except socket.error as msg:
    print(msg)
    sys.exit()
# 0 or IPPROTO_TCP for STREAM and 0 or IPPROTO_UDP for DGRAM. (man ip7). For SOCK_RAW you may specify a valid IANA IP protocol defined in RFC 1700 assigned numbers.
# IPPROTO_IP creates a socket that sends/receives raw data for IPv4-based protocols (TCP, UDP, etc). It will handle the IP headers for you, but you are responsible for processing/creating additional protocol data inside the IP payload.
# IPPROTO_RAW creates a socket that sends/receives raw data for any kind of protocol. It will not handle any headers for you, you are responsible for processing/creating all payload data, including IP and additional headers.(link)
packet = ''
src_ip = ""
dst_ip = ""
#######################
##Build Packet Header##
#######################
# Lets add the IPv4 header information
ip_ver_ihl = 69                         # This is putting the decimal conversion of 0x45 for Version and Internet Header Length
ip_tos = 0                             # This combines the DSCP and ECN feilds. Type of service/QoS
ip_len = 0                              # The kernel will fill in the actually length of the packet
ip_id = 0                            # This sets the IP Identification for the packet
ip_frag = 0                             # This sets fragmentation to off
ip_ttl = 1                             # This determines the TTL of the packet when leaving the machine
ip_proto = 6                           # This sets the IP protocol to 6 (TCP) so additional headers are required (reference IANA)
ip_check = 0                            # The kernel will fill in the checksum for the packet
ip_srcadd = socket.inet_aton(src_ip)    # inet_aton(string) will convert an IP address to a 32 bit binary number
ip_dstadd = socket.inet_aton(dst_ip)    # inet_aton(string) will convert an IP address to a 32 bit binary number
########################
## Pack the IP Header ##
########################
# This portion creates the header by packing the above variables into a structure. The ! in the string means 'Big-Endian' network order, while the code following specifies how to store the info. Endian explained. Refer to link for character meaning.
ip_header = pack('!BBHHHBBH4s4s' , ip_ver_ihl, ip_tos, ip_len, ip_id, ip_frag, ip_ttl, ip_proto, ip_check, ip_srcadd, ip_dstadd)
###########
##Message##
###########
# Your custom protocol fields or data. We are going to just insert data here. Add your message where the "?" is. Ensure you obfuscate it though...don't want any clear text messages being spotted! You can encode with various data encoding. Base64, binascii
message = b'last_name'                  #This should be the student's last name per the prompt
hidden_msg = binascii.hexlify(message)  #Students can choose which encoding they want to use.
#################
## Send Packet ##
#################
# final packet creation
packet = ip_header + hidden_msg
# Send the packet. Sendto is used when we do not already have a socket connected. Sendall or send if we do.
s.sendto(packet, (dst_ip, 0))
# socket.send is a low-level method and basically just the C/syscall method send(3) / send(2). It can send less bytes than you requested, but returns the number of bytes sent.
# socket.sendall is a high-level Python-only method that sends the entire buffer you pass or throws an exception. It does that by calling socket.send until everything has been sent or an error occurs.

STREAM.py
#!/usr/bin/python3
import socket
# create a socket
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)
# s = socket.socket() this is the same as above because we are using all defaults.
# use quotes ' ' to convert into a string
ip_addr = '127.0.0.1'
port = 1234
# connect is use to tell it to connect to the ((address, port))
# no quotes needed because its already a integer value
s.connect((ip_addr, port))
# send a string to the target - prefix b'message' to make a bytes-like object.
# Python3 does not like strings sent by itself
message = b"CCTC"
# = \n is for inline or send carriage return.
# Send the message to the target. The socket must be connected to a remote socket.
s.send(message)
# s = socket variable
# send = method
# (message) = the message variable
# Receive data from the socket.
# Split the return message into two variables. The return value is a pair (bytes(data), address(ip and port))
data, conn = s.recvfrom(1024)
# You can optionally use s.recv but it will only return (bytes)
# Default encoding is 'utf-8'. errors may be given to set a different error handling scheme.
# The default for errors is 'strict', meaning that encoding errors raise a UnicodeError.
# print the response from the receiver. UTF-8 is default. Others are UTF-16, UTF-32, ASCII, EBCIDIC
print(data.decode('utf-8'))
# close = function to close connection else it will hang
s.close()




TCP_RAW.py
#!/usr/bin/python3
# For building the socket
import socket
# For system level commands
import sys
# For doing an array in the TCP checksum
import array
# For establishing the packet structure (Used later on), this will allow direct access to the methods and functions in the struct module
from struct import *
# For encoding
import base64               # base64 module
import binascii            # binascii module
# Create a raw socket.
try:
    s = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_RAW)
except socket.error as msg:
    print(msg)
    sys.exit()
# 0 or IPPROTO_TCP for STREAM and 0 or IPPROTO_UDP for DGRAM. (man ip7). For SOCK_RAW you may specify a valid IANA IP protocol defined in RFC 1700 assigned numbers.
# IPPROTO_IP creates a socket that sends/receives raw data for IPv4-based protocols (TCP, UDP, etc). It will handle the IP headers for you, but you are responsible for processing/creating additional protocol data inside the IP payload.
# IPPROTO_RAW creates a socket that sends/receives raw data for any kind of protocol. It will not handle any headers for you, you are responsible for processing/creating all payload data, including IP and additional headers.(link)
packet = ''
src_ip = ""
dst_ip = ""
#######################
##Build Packet Header##
#######################
# Lets add the IPv4 header information
ip_ver_ihl = 69                         # This is putting the decimal conversion of 0x45 for Version and Internet Header Length
ip_tos = 0                             # This combines the DSCP and ECN fields. Type of service/QoS
ip_len = 0                              # The kernel will fill in the actually length of the packet
ip_id = 0                            # This sets the IP Identification for the packet
ip_frag = 0                             # This sets fragmentation to off
ip_ttl = 16                             # This determines the TTL of the packet when leaving the machine
ip_proto = 6                           # This sets the IP protocol to 6 (TCP) so additional headers are required (reference IANA)
ip_check = 0                            # The kernel will fill in the checksum for the packet
ip_srcadd = socket.inet_aton(src_ip)    # inet_aton(string) will convert an IP address to a 32 bit binary number
ip_dstadd = socket.inet_aton(dst_ip)    # inet_aton(string) will convert an IP address to a 32 bit binary number
########################
## Pack the IP Header ##
########################
# This portion creates the header by packing the above variables into a structure. The ! in the string means 'Big-Endian' network order, while the code following specifies how to store the info. Endian explained. Refer to link for character meaning.
ip_header = pack('!BBHHHBBH4s4s' , ip_ver_ihl, ip_tos, ip_len, ip_id, ip_frag, ip_ttl, ip_proto, ip_check, ip_srcadd, ip_dstadd)
####################
##Build TCP Header##
####################
tcp_src = 0                         # source port
tcp_dst = 0                          # destination port
tcp_seq = 0                        # sequence number
tcp_ack_seq = 0                     # tcp ack sequence number
tcp_data_off = 5                        # data offset specifying the size of tcp header * 4 which is 20
tcp_reserve = 0                         # the 3 reserve bits + ns flag in reserve field
tcp_flags = 0                           # tcp flags field before the bits are turned on
tcp_win = 65535                         # maximum allowed window size reordered to network order (socket.htons is deprecated)
tcp_chk = 0                             # tcp checksum which will be calculated later on
tcp_urg_ptr = 0                         # urgent pointer only if urg flag#!/usr/bin/python3
# For building the socket
import socket
# For system level commands
import sys
# For doing an array in the TCP checksum
import array
# For establishing the packet structure (Used later on), this will allow direct access to the methods and functions in the struct module
from struct import *
# For encoding
import base64               # base64 module
import binascii            # binascii module
# Create a raw socket.
try:
    s = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_RAW)
except socket.error as msg:
    print(msg)
    sys.exit()
# 0 or IPPROTO_TCP for STREAM and 0 or IPPROTO_UDP for DGRAM. (man ip7). For SOCK_RAW you may specify a valid IANA IP protocol defined in RFC 1700 assigned numbers.
# IPPROTO_IP creates a socket that sends/receives raw data for IPv4-based protocols (TCP, UDP, etc). It will handle the IP headers for you, but you are responsible for processing/creating additional protocol data inside the IP payload.
# IPPROTO_RAW creates a socket that sends/receives raw data for any kind of protocol. It will not handle any headers for you, you are responsible for processing/creating all payload data, including IP and additional headers.(link)
packet = ''
src_ip = ""
dst_ip = ""
#######################
##Build Packet Header##
#######################
# Lets add the IPv4 header information
ip_ver_ihl = 69                         # This is putting the decimal conversion of 0x45 for Version and Internet Header Length
ip_tos = 0                             # This combines the DSCP and ECN fields. Type of service/QoS
ip_len = 0                              # The kernel will fill in the actually length of the packet
ip_id = 0                            # This sets the IP Identification for the packet
ip_frag = 0                             # This sets fragmentation to off
ip_ttl = 16                             # This determines the TTL of the packet when leaving the machine
ip_proto = 6                           # This sets the IP protocol to 6 (TCP) so additional headers are required (reference IANA)
ip_check = 0                            # The kernel will fill in the checksum for the packet
ip_srcadd = socket.inet_aton(src_ip)    # inet_aton(string) will convert an IP address to a 32 bit binary number
ip_dstadd = socket.inet_aton(dst_ip)    # inet_aton(string) will convert an IP address to a 32 bit binary number
########################
## Pack the IP Header ##
########################
# This portion creates the header by packing the above variables into a structure. The ! in the string means 'Big-Endian' network order, while the code following specifies how to store the info. Endian explained. Refer to link for character meaning.
ip_header = pack('!BBHHHBBH4s4s' , ip_ver_ihl, ip_tos, ip_len, ip_id, ip_frag, ip_ttl, ip_proto, ip_check, ip_srcadd, ip_dstadd)
####################
##Build TCP Header##
####################
tcp_src = 0                         # source port
tcp_dst = 0                          # destination port
tcp_seq = 0                        # sequence number
tcp_ack_seq = 0                     # tcp ack sequence number
tcp_data_off = 5                        # data offset specifying the size of tcp header * 4 which is 20
tcp_reserve = 0                         # the 3 reserve bits + ns flag in reserve field
tcp_flags = 0                           # tcp flags field before the bits are turned on
tcp_win = 65535                         # maximum allowed window size reordered to network order (socket.htons is deprecated)
tcp_chk = 0                             # tcp checksum which will be calculated later on
tcp_urg_ptr = 0                         # urgent pointer only if urg flag is set
# Combine the left shifted 4 bit tcp offset and the reserve field
tcp_off_res = (tcp_data_off << 4) + tcp_reserve
# Tcp flags by bit starting from right to left
tcp_fin = 0                             # Finished
tcp_syn = 0                             # Synchronization
tcp_rst = 0                             # Reset
tcp_psh = 0                             # Push
tcp_ack = 0                             # Acknowledgment
tcp_urg = 0                             # Urgent
tcp_ece = 0                             # Explicit Congestion Notification Echo
tcp_cwr = 0                             # Congestion Window Reduced
# Combine the tcp flags by left shifting the bit locations and adding the bits together
tcp_flags = tcp_fin + (tcp_syn << 1) + (tcp_rst << 2) + (tcp_psh << 3) + (tcp_ack << 4) + (tcp_urg << 5) + (tcp_ece << 6) + (tcp_cwr << 7)
# The ! in the pack format string means network order
tcp_hdr = pack('!HHLLBBHHH', tcp_src, tcp_dst, tcp_seq, tcp_ack_seq, tcp_off_res, tcp_flags, tcp_win, tcp_chk, tcp_urg_ptr)
###########
##Message##
###########
# Your custom protocol fields or data. We are going to just insert data here. Add your message where the "?" is. Ensure you obfuscate it though...don't want any clear text messages being spotted! You can encode with various data encoding. Base64, binascii
message = b'last_name'                  #This should be the student's last name per the prompt
############################
##Create the Pseudo Header##
############################
# After you create the tcp header, create the pseudo header for the tcp checksum.
src_address = socket.inet_aton(src_ip)
dst_address = socket.inet_aton(dst_ip)
reserved = 0
protocol = socket.IPPROTO_TCP
tcp_length = len(tcp_hdr) + len(message)
##########################
##Pack the Pseudo Header##
##########################
ps_hdr = pack('!4s4sBBH', src_address, dst_address, reserved, protocol, tcp_length)
ps_hdr = ps_hdr + tcp_hdr + message
################################
##Define the Checksum Function##
################################
def checksum(data):
        if len(data) % 2 != 0:
                data += b'\0'
        res = sum(array.array("H", data))
        res = (res >> 16) + (res & 0xffff)
        res += res >> 16
        return (~res) & 0xffff
tcp_chk = checksum(ps_hdr)
##################
##Final TCP Pack##
##################
# Pack the tcp header to fill in the correct checksum - remember checksum is NOT in network byte order
tcp_hdr = pack('!HHLLBBH', tcp_src, tcp_dst, tcp_seq, tcp_ack_seq, tcp_off_res, tcp_flags, tcp_win) + pack('H', tcp_chk) + pack('!H', tcp_urg_ptr)
#################
## Send Packet ##
#################
# Combine all of the headers and the user data
packet = ip_header + tcp_hdr + message
# Send the packet. Sendto is used when we do not already have a socket connected. Sendall or send if we do.
s.sendto(packet, (dst_ip, 0))
# socket.send is a low-level method and basically just the C/syscall method send(3) / send(2). It can send less bytes than you requested, but returns the number of bytes sent.
# socket.sendall is a high-level Python-only method that sends the entire buffer you pass or throws an exception. It does that by calling socket.send until everything has been sent or an error occurs. is set
# Combine the left shifted 4 bit tcp offset and the reserve field
tcp_off_res = (tcp_data_off << 4) + tcp_reserve
# Tcp flags by bit starting from right to left
tcp_fin = 0                             # Finished
tcp_syn = 0                             # Synchronization
tcp_rst = 0                             # Reset
tcp_psh = 0                             # Push
tcp_ack = 0                             # Acknowledgment
tcp_urg = 0                             # Urgent
tcp_ece = 0                             # Explicit Congestion Notification Echo
tcp_cwr = 0                             # Congestion Window Reduced
# Combine the tcp flags by left shifting the bit locations and adding the bits together
tcp_flags = tcp_fin + (tcp_syn << 1) + (tcp_rst << 2) + (tcp_psh << 3) + (tcp_ack << 4) + (tcp_urg << 5) + (tcp_ece << 6) + (tcp_cwr << 7)
# The ! in the pack format string means network order
tcp_hdr = pack('!HHLLBBHHH', tcp_src, tcp_dst, tcp_seq, tcp_ack_seq, tcp_off_res, tcp_flags, tcp_win, tcp_chk, tcp_urg_ptr)
###########
##Message##
###########
# Your custom protocol fields or data. We are going to just insert data here. Add your message where the "?" is. Ensure you obfuscate it though...don't want any clear text messages being spotted! You can encode with various data encoding. Base64, binascii
message = b'last_name'                  #This should be the student's last name per the prompt
############################
##Create the Pseudo Header##
############################
# After you create the tcp header, create the pseudo header for the tcp checksum.
src_address = socket.inet_aton(src_ip)
dst_address = socket.inet_aton(dst_ip)
reserved = 0
protocol = socket.IPPROTO_TCP
tcp_length = len(tcp_hdr) + len(message)
##########################
##Pack the Pseudo Header##
##########################
ps_hdr = pack('!4s4sBBH', src_address, dst_address, reserved, protocol, tcp_length)
ps_hdr = ps_hdr + tcp_hdr + message
################################
##Define the Checksum Function##
################################
def checksum(data):
        if len(data) % 2 != 0:
                data += b'\0'
        res = sum(array.array("H", data))
        res = (res >> 16) + (res & 0xffff)
        res += res >> 16
        return (~res) & 0xffff
tcp_chk = checksum(ps_hdr)
##################
##Final TCP Pack##
##################
# Pack the tcp header to fill in the correct checksum - remember checksum is NOT in network byte order
tcp_hdr = pack('!HHLLBBH', tcp_src, tcp_dst, tcp_seq, tcp_ack_seq, tcp_off_res, tcp_flags, tcp_win) + pack('H', tcp_chk) + pack('!H', tcp_urg_ptr)
#################
## Send Packet ##
#################
# Combine all of the headers and the user data
packet = ip_header + tcp_hdr + message
# Send the packet. Sendto is used when we do not already have a socket connected. Sendall or send if we do.
s.sendto(packet, (dst_ip, 0))
# socket.send is a low-level method and basically just the C/syscall method send(3) / send(2). It can send less bytes than you requested, but returns the number of bytes sent.
# socket.sendall is a high-level Python-only method that sends the entire buffer you pass or throws an exception. It does that by calling socket.send until everything has been sent or an error occurs.

AddressFamilies. Level I Challenge
What are the 3 Address Families associated with the python3 socket module?
example: socket.ADDFAM, socket.ADDFAM, socket.ADDFAM
Answer: socket.AF_UNIX, socket.AF_INET, socket.AF_INET6

Connections. Level I Challenge
What are the two socket functions called to open a connection and to disconnect from that connection?
example: socket.fun(), socket.func()
Answer: socket.connect(), socket.close()

Header Preparation. Level I Challenge
What python3 library function is utilized to combine the various pieces of your raw socket packet into network order?
example: module.function
Answer: struct.pack

Missing Data. What must be manually created with raw sockets that stream and datagram sockets creates for you?
Answer: header

Sending UDP. What function within the socket module allows you to Send data to a socket, while not already being connected to a remote socket?
example: socket.func()Objects
5
Level I Challenge

When sending data across a connection, what must a string be converted to before being sent due to encoding?

Answer: socket.sendto()

Transport Layer Sockets. Provide an example of the two required items needed to be set in order to send a Datagram or Stream socket? (excluding any of the socket.socket functions)
example: item1 item2
Answer: ip address port

Objects. When sending data across a connection, what must a string be converted to before being sent due to encoding?
Answer: bytes-like object

Gorgas Socket Manipulation (GPM)
XX OCT 2023
Start Time: 1300
Duration: 4 hours

Type of Operation: Socket Programming for Datagram, IP, TCP

Objective: Gorgas Cyber Forces are preparing for an upcoming mission and have requested assistance with packet manipulation. They need to send custom message to allied forces throughout the region; however, they currently do not have anyone available that understands how. Using Python your team is required to complete each of the following tasks (Specific details for each task are identified in the challenge):

    Utilize sockets and craft a custom Raw IPv4 Sockets

    Utilize sockets and craft a custom Raw IPv4 TCP Sockets

    Utilize sockets and craft a custom Datagram Socket Message Sender

    Utilize sockets and craft a custom Stream Socket Message Sender

Click Here to view there current progress on the scripts

Tools/Techniques: Python3, Wireshark/TCPDump

Scenario Credentials: FLAG = raw_packet_start

Prior Approvals: Prior to completing each of the four tasks, ensure you understand the various items of the script you developed.

Scheme of Maneuver:
> Linux Workstations:
→ T1: INTERNET_HOST
-→ T2: BLUE_DMZ_Host

Target Section:

T1
Hostname: INTERNET_HOST
IP: PROVIDED FLOAT IP
OS: Linux
Creds: PROVIDED CREDENTIALS
Last Known SSH Port: 22
PSP: none
Malware: none
Action: Send a Datagram Socket Message to this host

T2
Hostname: BLUE_DMZ_Host-1
IP: 172.16.1.15
OS: unknown
Creds:unknown
Last Known SSH Port: unknown
PSP: Unknown
Malware: Unknown
Action: Send a Stream Socket Message to this host


Stream Socket Message Sender. Gorgan Forces have requested you get a message to one of their remote teams that are utilizing the BLUE_DMZ_HOST-1. Utilizing the criteria they provided, generate a stream socket with python3:
Coded information was placed into the video below. Look at the note the woman passes to the man.
https://youtu.be/6WTdTwcmxyo?t=35
    From your INTERNET-HOST to the BLUE_DMZ_HOST-1
    Port number = #Last four digits on the note
    Message = #Name on the note (First letter capitalized)
STREAM_v1.py
#!/usr/bin/python3
import socket
# create a socket
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)
# s = socket.socket() this is the same as above because we are using all defaults.
# use quotes ' ' to convert into a string
ip_addr = '172.16.1.15'
port = 5309
# connect is use to tell it to connect to the ((address, port))
# no quotes needed because its already a integer value
s.connect((ip_addr, port))
# send a string to the target - prefix b'message' to make a bytes-like object.
# Python3 does not like strings sent by itself
message = b"Jenny"
# = \n is for inline or send carriage return.
# Send the message to the target. The socket must be connected to a remote socket.
s.send(message)
# s = socket variable
# send = method
# (message) = the message variable
# Receive data from the socket.
# Split the return message into two variables. The return value is a pair (bytes(data), address(ip and port))
data, conn = s.recvfrom(1024)
# You can optionally use s.recv but it will only return (bytes)
# Default encoding is 'utf-8'. errors may be given to set a different error handling scheme.
# The default for errors is 'strict', meaning that encoding errors raise a UnicodeError.
# print the response from the receiver. UTF-8 is default. Others are UTF-16, UTF-32, ASCII, EBCIDIC
print(data.decode('utf-8'))
# close = function to close connection else it will hang
s.close()

Datagram Socket Message Sender. Gorgan Forces have requested you get a message to one of their remote teams that are utilizing the INTERNET_HOST. Utilizing the criteria they provided, generate a datagram socket with python3:
Coded information was placed into the video below. Listen to the words in the video.
https://youtu.be/OuK4OcMUGcg?t=67
    Send to your INTERNET-HOST localhost.
    Port number = #The number of fists
    Message = #The name of the band (First letter capitalized)
Message = Disturbed
port  = 10000

DGRAM_v1.py
#!/usr/bin/python3
import socket
s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, 0)
ip_addr = '127.0.0.1'
port = 10000
# Connect to a remote socket at address.
# s.connect((ip_addr, port)) # typically used for TCP
message = b"Disturbed"
#Send data to the socket. The socket should not be connected to a remote socket. Typically used for UDP.
s.sendto (message, (ip_addr, port))
#Receive data from the socket. The return value is a pair (bytes, address) where bytes is a bytes object representing the data received$
data, addr = s.recvfrom(1024)
# You can optionally use s.recv but it will only return (bytes)
#Default encoding is 'utf-8'. errors may be given to set a different error handling scheme. The default for errors is 'strict', meaning$
print(data.decode())
# using "utf-8" default

Raw IPv4 Socket. Gorgan forces, tool development cell have provided RAWSOCK.py for your teams use, it defines the basic structure of the desired result.
    Create a raw socket and code your message into the socket
    Send your last name as the data.
    The sent data is required to be encoded, with a final result of the data being in hex. You can use the python module of your choice; a good module to start with is binascii.
    When viewing in Wireshark, the packet should not be malformed
Target IP: 172.16.1.15
TOS: 96
IP ID: 1984
Protocol: CHAOS
The flag will be provided by the Mission Command once you complete the activity.
    Provide the Wireshark Packet Capture.
    Provide proof of the decoded message.
RAW.py
#!/usr/bin/python3
import socket
import sys
from struct import *
import base64               # base64 module
import binascii            # binascii module
try:
    s = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_RAW)
except socket.error as msg:RAW.py
#!/usr/bin/python3
import socket
import sys
from struct import *
import base64               # base64 module
import binascii            # binascii module
try:
    s = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_RAW)
except socket.error as msg:
    print(msg)
    sys.exit()
packet = ''
src_ip = "10.10.0.40"
dst_ip = "172.16.1.15"
ip_ver_ihl = 69                         # This is putting the decimal conversion of 0x45 for Version and Internet Header Length
ip_tos = 96                             # This combines the DSCP and ECN feilds. Type of service/QoS
ip_len = 0                              # The kernel will fill in the actually length of the packet
ip_id = 1984                            # This sets the IP Identification for the packet
ip_frag = 0                             # This sets fragmentation to off
ip_ttl = 1                             # This determines the TTL of the packet when leaving the machine
ip_proto = 16                           # This sets the IP protocol to 6 (TCP) so additional headers are required (reference IANA)
ip_check = 0                            # The kernel will fill in the checksum for the packet
ip_srcadd = socket.inet_aton(src_ip)    # inet_aton(string) will convert an IP address to a 32 bit binary number
ip_dstadd = socket.inet_aton(dst_ip)    # inet_aton(string) will convert an IP address to a 32 bit binary number
ip_header = pack('!BBHHHBBH4s4s' , ip_ver_ihl, ip_tos, ip_len, ip_id, ip_frag, ip_ttl, ip_proto, ip_check, ip_srcadd, ip_dstadd)
message = b'last_name'                  #This should be the student's last name per the prompt
hidden_msg = binascii.hexlify(message)  #Students can choose which encoding they want to use.
packet = ip_header + hidden_msg
s.sendto(packet, (dst_ip, 0))
    print(msg)
    sys.exit()
packet = ''
src_ip = "10.10.0.40"
dst_ip = "172.16.1.15"
ip_ver_ihl = 69                         # This is putting the decimal conversion of 0x45 for Version and Internet Header Length
ip_tos = 96                             # This combines the DSCP and ECN feilds. Type of service/QoS
ip_len = 0                              # The kernel will fill in the actually length of the packet
ip_id = 1984                            # This sets the IP Identification for the packet
ip_frag = 0                             # This sets fragmentation to off
ip_ttl = 1                             # This determines the TTL of the packet when leaving the machine
ip_proto = 16                           # This sets the IP protocol to 6 (TCP) so additional headers are required (reference IANA)
ip_check = 0                            # The kernel will fill in the checksum for the packet
ip_srcadd = socket.inet_aton(src_ip)    # inet_aton(string) will convert an IP address to a 32 bit binary number
ip_dstadd = socket.inet_aton(dst_ip)    # inet_aton(string) will convert an IP address to a 32 bit binary number
ip_header = pack('!BBHHHBBH4s4s' , ip_ver_ihl, ip_tos, ip_len, ip_id, ip_frag, ip_ttl, ip_proto, ip_check, ip_srcadd, ip_dstadd)
message = b'last_name'                  #This should be the student's last name per the prompt
hidden_msg = binascii.hexlify(message)  #Students can choose which encoding they want to use.
packet = ip_header + hidden_msg
s.sendto(packet, (dst_ip, 0))


Network Reconnaissance
start flag: ready_set_scan
dig - discover records
dig www.google.com A/mx/txt/aaaa/

whois

nc 172.16.82.106
wget -r ftp://172.16.82.106
find / *.flag 2&>/dev/null
VyOS username: vyos password: password
use shodan for router
the map
hostnames
ips/cider
macs
interfaces
$ for i in {96..127}; do ping -c 1 172.16.182.$i;done |egrep 'bytes from'
64 bytes from 172.16.182.106: icmp_seq=1 ttl=59 time=2.56 ms
64 bytes from 172.16.182.110: icmp_seq=1 ttl=59 time=3.15 ms
64 bytes from 172.16.182.114: icmp_seq=1 ttl=59 time=2.94 ms
64 bytes from 172.16.182.118: icmp_seq=1 ttl=59 time=3.73 ms
64 bytes from 172.16.182.126: icmp_seq=1 ttl=60 time=1.99 ms

router
IP: 172.16.120.1
Ports: 22
Username: vyos
Password: password

1. Donovian Boundary. Utilizing the intelligence already provided, what is it’s hostname of their boundary router?
example: student@HOSTNAME-student-1
Copy only the name where HOSTNAME is at.
Going forward, you will need to use Vyos CLI commands to continue looking at what the routers know about. The reference is in Section 3 in your Student Resources.
Answer: RED-SCR



Data transfer, Movement, and Redirection

<cmd> <from> <to>
pull
scp student@ip:stuff.txt /home/student
upload
scp stuff.txt student@ip:/home/student
copy remote to remote
scp -3 student1@ip1:/home/student/stuff.txt student2@ip2:/home/student

SCP syntax with alternate SSHD
download a file from a remote directory to a local directory
scp -P 1111 student@ip:stuff.txt /home/student
upload 
scp -P 1111 stuff.txt student@ip:/home/student

scp syntax through a tunnel
set up a listening port
authenticate to box, -L for localport:localhost, -NT for don't execute remote command and disable pseudo terminal
ssh student@ip -L 1111:localhost:22 -NT

ssh -p 1111 student@ip

check arp cache
ip nei

port forward
(instead of using local host, target a box behind what you can access)
ssh student@ip -L 1111:192.168.1.10:22 -NT

on the "middle" box
ssh -p 1111 student@localhost
this should get you into the distant box

traffic redirection

netcat
inbound/outbount tcp/udp to from any ports
troubleshoot network connections
send/receive data (insecure)
prot scanning (like -sT in Nmap)
can not be used for port forwarding

client to listener file transffer
client sends file: nc 10.10.0.40 9001 < file.txt (transfers the content of the file, not the entire file to include the name)
listener receives file: nc -l -p 9001 > newfile.txt
(listener has to be set up first!)

NETCAT Relay Demos
On Client Relay:
mknod mypipe p
nc 10.1.0.2 9002 0< mypipe | nc 10.2.0.2 9001 1> mypipe
On Listener2 (sends info):
nc -l -p 9002 < infile.txt
On Listener1 (receives info):
nc -l -p 9001 > outfile.txt
Writes the output to listener1 and listener2 through the named pipe 

mknod PIPE1 p
or
mkfifo PIPE2

ssh
ssh -p <optional port> <user>@<pivot IP> -L <local bind port>
or
ssh -L  <local bind port>:<tgt ip>:<tgt port> -p <alt port> <user>@<pivot ip> -NT

-L localhost:localport:TGTip:tgtport

local port forwarding
ssh student@ip -L 1111:ip:80 -NT (when specifying a specific port, you can only do those kinds of things 80 = http)
or
ssh -L 1111:ip:80 student@ip -NT

ssh student@10.2.0.2 -L 1111:10.3.0.2:22 -NT
ssh student@localhost -p 1111 -L 2222:34.233.98.14:80 -NT
firefox localhost:2222
#creates an additional local port on the local host that forwards to a target machine through the prevous channel created.

Dynamic Port Forwarding
Allows you to take your tools with you while you tunnel
ssh -D <port> -p <alt port> <user>@<pivot ip> -NT
proxychains default port is 9050
creates a dynamic socks4 proxy that interacts alone, or with a previously established remote or local port forward.
Allows the user of scripts and other userspace programs through the tunnel.
*****Need to supress nmap icmp. (namp -Pn)*****
Can't run local commands (ip addr) through dynamic. 
ex:
net1:
ssh student@10.2.0.2 -L 1111:10.3.0.2:2222 -NT
ssh student@localhost -D 9050 -p 1111 -NT
proxychains curl ftp://www.onlineftp.ch
proxychains wget -r www.espn.com
proxychains ./scan.sh
proxychains ssh user@192.0.2.100 -p 2022

Task 1

T1
Hostname: INTERNET_HOST
External IP: 10.50.XXX.XXX (ALREADY PROVIDED) Internal IP: 10.10.0.40 (ALREADY PROVIDED) (accessed via FLOAT IP)
creds: (ALREADY PROVIDED)
Action: Successfully transfer file data between hosts via Netcat

T2
Hostname: BLUE_HOST-4
IP: 172.16.82.115
creds: (NONE)
Action: Successfully transfer files from this host using Netcat

RELAY
Hostname: BLUE_INT_DMZ_HOST-1
IP: 172.16.40.10
creds: (ALREADY PROVIDED)
Action: Successfully transfer file data between hosts via Netcat

on host, set up listener
nc -l -p 5555 > steg1
on relay
make a pipe
nc -l -p 1234 < mypipe | nc 10.10.0.40 5555 > mypipe 
on host, wait for the file to transfer then 
ls -l
steghide extrace -sf steg1
md5sum on the extracted file to get the hash and submit the flag

3&4
on int-dmz (relay)
nc 10.10.0.40 6666 < mypipe | nc 172.16.82.115 9876 > mypipe
on host
nc -lvp 6666 > 4steg

Remote Port Forward
-R remotehost:remoteport:tgtIP:tgtPort
ex:
ssh student@10.1.0.2 -R 1111:localhost:80 -NT
localhost is the tgt
1111 will show up on 10.1.0.2

SSH remote and local port forwarding

extra1:
ssh student@10.3.0.2 -R 1111 :localhost22 -NT
net1:
ssh student@10.3.0.2 -L 2222"localhost:1111 -NT
net1:
ssh localhost -p 2222

task3

1. Tunnel Prep – What is localhost. What is the word "localhost" associated with? (Max 2 Attempts)
A. Loopback address
B. 127.0.0.1
C. Both A and B.
D. None of the above.
Answer 3

2. Tunnel Prep – Alternate port 1. Using the following syntax:
OPS$ ssh cctc@10.50.1.150 -p 1111
What is 1111? (Max 2 Attempts)
A. nothing. Incorrect syntax
B. alternate ssh port on 10.50.1.150
C. local listening port on OPS
D. port mapped to localhost on 10.50.1.150
Answer: b

3. Tunnel Prep – Alternate port 2. Using the following syntax:
OPS$ ssh cctc@localhost -p 1111
What is 1111? (Max 2 Attempts)
A. nothing. Incorrect syntax
B. alternate ssh port on 10.50.1.150
C. local listening port on OPS
D. port mapped to localhost on 10.50.1.150 
Answer: c

4. Tunnel Prep – Fill in the blank. Using the Tunnels Prep Diagram provided in the start to this task, please fill in the blanks to complete the following ssh command.
Which IP would we use to SSH to PC1 from OPS?
ssh cctc@__________
Answer: 10.50.1.150

5. Tunnel Prep – Dynamic. Using the Tunnels Prep Diagram provided in the start to this task, please fill in the blanks to complete the following ssh command.
Which ssh syntax would properly setup a Dynamic tunnel to PC1? (Max 2 Attempts)
A. ssh -D 9050 cctc@localhost -NT
B. ssh cctc@100.1.1.1 -D 9050 -NT
C. ssh cctc@10.50.1.150 -D 9050 -NT
D. ssh -L 9050 cctc@10.50.1.150 -NT 
Answer: c

6. Tunnel Prep – Local to SSH. Using the Tunnels Prep Diagram provided in the start to this task, please fill in the blanks to complete the following ssh command.
Which ssh syntax would properly setup a Local tunnel to PC1 SSH port? (Max 2 Attempts)
A. ssh -L 1111:localhost:22 cctc@10.50.1.150 -NT
B. ssh cctc@10.50.1.150 -L 1111:10.50.1.150:22 -NT
C. ssh cctc@100.1.1.1 -L 1111:localhost:22 -NT
D. ssh -R 1111:localhost:22 cctc@10.50.1.150 -NT 
Answer: a

7. Tunnel Prep – Local to HTTP. Using the Tunnels Prep Diagram provided in the start to this task, please fill in the blanks to complete the following ssh command.
Which ssh syntax would properly setup a Local tunnel to PC1 HTTP port? (Max 2 Attempts)
A. ssh cctc@100.1.1.1 -L 1111:10.50.1.150:80 -NT
B. ssh cctc@10.50.1.150 -L 1111:localhost:80 -NT
C. ssh cctc@100.1.1.1 -L 1111:localhost:80 -NT
D. ssh -L 1111:100.1.1.1:80 cctc@localhost -NT 
Answer: b

8. Tunnel Prep – Dynamic thru 1st Local. Using the Tunnels Prep Diagram provided in the start to this task, please fill in the blanks to complete the following ssh command.
Which ssh syntax would allow us to establish a Dynamic tunnel using the Local tunnel created in Question 6? (Max 2 Attempts)
A. ssh -D 9050 cctc@localhost -NT
B. ssh cctc@100.1.1.1 -p 1111 -D 9050 -NT
C. ssh -p 1111 cctc@10.50.1.150 -D 9050 -NT
D. ssh -D 9050 cctc@localhost -p 1111 -NT 
Answer: d

9. Tunnel Prep – Pull HTTP thru Local. Using the Tunnels Prep Diagram provided in the start to this task, please fill in the blanks to complete the following ssh command.
Which syntax would allow us to download the webpage of PC1 using the Local tunnel created in Question 7? (Max 2 Attempts)
A. wget -r http://100.1.1.1:1111
B. wget -r http://100.1.1.1
C. wget -r http://localhost:1111
D. wget -r http://localhost -p 1111 
Answer: c

10. Tunnel Prep – Pull HTTP thru Dynamic. Using the Tunnels Prep Diagram provided in the start to this task, please fill in the blanks to complete the following ssh command.
Which syntax would allow us to download the webpage of PC2 using the Dynamic tunnel created in Question 8? (Max 2 Attempts)
A. proxychains wget -r http://100.1.1.2:1111
B. proxychains wget -r http://100.1.1.2
C. proxychains curl http://100.1.1.2
D. wget -r http://localhost:1111 
Answer: b

11. Tunnel Prep – Local to 2nd Pivot SSH. Using the Tunnels Prep Diagram provided in the start to this task, please fill in the blanks to complete the following ssh command.
Which ssh syntax would properly setup a Local tunnel to PC2 SSH port using PC1 as your pivot? (Max 2 Attempts)
A. ssh cctc@10.50.1.150 -L 1111:192.168.2.1:22 -NT
B. ssh -L 1111:100.1.1.2:22 cctc@100.1.1.1 -NT
C. ssh -L 1111:100.1.1.2:22 cctc@10.50.1.150 -p 1111 -NT
D. ssh cctc@10.50.1.150 -L 1111:100.1.1.2:22 -NT 
Answer: d

12. Tunnel Prep – 2nd Local thru 1st Local SSH. Using the Tunnels Prep Diagram provided in the start to this task, please fill in the blanks to complete the following ssh command.
Which ssh syntax would properly setup a 2nd Local tunnel to PC2 SSH port using the tunnel made in Question 6 as your first tunnel? (Max 2 Attempts)
A. ssh -L 2222:100.1.1.2:22 cctc@localhost -p 1111 -NT
B. ssh -L 2222:100.1.1.2:22 cctc@10.50.1.150 -p 1111 -NT
C. ssh cctc@100.1.1.1 -p 1111 -L 2222:100.1.1.2:22 -NT
D. ssh cctc@localhost -p 1111 -L 2222:192.168.2.1:22 -NT 
Answer: a

13. Tunnel Prep – 2nd Local thru 1st Local HTTP. Using the Tunnels Prep Diagram provided in the start to this task, please fill in the blanks to complete the following ssh command.
Which ssh syntax would properly setup a 2nd Local tunnel to PC2 HTTP port using the tunnel made in Question 6 as your first tunnel? (Max 2 Attempts)
A. ssh -L 2222:192.168.2.1:80 cctc@localhost -p 1111 -NT
B. ssh cctc@localhost -p 1111 -L 2222:100.1.1.2:80 -NT
C. ssh cctc@10.50.1.150 -p 1111 -L 2222:100.1.1.2:80 -NT
D. ssh -L 2222:100.1.1.2:80 cctc@100.1.1.1 -p 1111 -NT
Answer: b

14. Tunnel Prep – Dynamic thru 2nd Local. Using the Tunnels Prep Diagram provided in the start to this task, please fill in the blanks to complete the following ssh command.
Which ssh syntax would allow us to establish a Dynamic tunnel using the Local tunnel created in Question 12? (Max 2 Attempts)
A. ssh -D 9050 cctc@localhost -p 2222 -NT
B. ssh cctc@100.1.1.1 -p 2222 -D 9050 -NT
C. ssh -p 2222 cctc@10.50.1.150 -D 9050 -NT
D. ssh -D 9050 cctc@localhost -p 1111 -NT 
Answer: a

15. Tunnel Prep – What’s Wrong 1. Using the Tunnels Prep Diagram provided in the start to this task, please fill in the blanks to complete the following ssh command.
An Admin created the following tunnels but found that the Dynamic tunnel would not connect. Where did the Admin make the error? (Max 2 Attempts)
1.) ssh cctc@10.50.1.150 -L 1234:100.1.1.2:22 -NT
2.) ssh -D 9050 cctc@100.1.1.2 -p 1234 -NT
A. targeted wrong IP in line 1
B. authenticated to wrong IP in line 1
C. authenticated to wrong IP in line 2
D. called wrong port in line 2
Answer: c

16. Tunnel Prep – What’s Wrong 2. Using the Tunnels Prep Diagram provided in the start to this task, please fill in the blanks to complete the following ssh command.
An Admin created the following tunnels but found that the Dynamic tunnel would not connect. Where did the Admin make the error? (Max 2 Attempts)
1.) ssh cctc@10.50.1.150 -L 1234:192.168.2.1:22 -NT
2.) ssh -L 4321:100.1.1.2:22 cctc@localhost -p 1234 -NT
3.) ssh cctc@localhost -p 4321 -D 9050 -NT
A. targeted wrong IP in line 1
B. targeted wrong IP in line 2
C. called wrong port in line 2
D. called wrong port in line 3 
Answer: a

17. Tunnel Prep – Local to 3rd Pivot TELNET. Using the Tunnels Prep Diagram provided in the start to this task, please fill in the blanks to complete the following ssh command.
Which ssh syntax would properly setup a 3rd Local tunnel to PC3 TELNET port using the tunnels made in Question 6 and Question 12? (Max 2 Attempts)
A. ssh -L 3333:192.168.2.2:23 -p 2222 cctc@100.1.1.1 -NT
B. ssh -p 2222 cctc@localhost -L 3333:192.168.2.1:23 -NT
C. ssh -L 3333:192.168.2.2:23 cctc@localhost -NT
D. ssh -p 2222 cctc@localhost -L 3333:192.168.2.2:23 -NT 
Answer: d

18. Tunnel Prep – Telnet to 3rd Pivot. Using the Tunnels Prep Diagram provided in the start to this task, please fill in the blanks to complete the following ssh command.
Which syntax would allow us to telnet to PC3 using the tunnel make in Question 17? (Max 2 Attempts)
A. telnet localhost:3333
B. telnet localhost 3333
C. telnet 192.168.2.2 3333
D. telnet localhost -p 3333 
Answer: b

19. Tunnel Prep – Remote. Using the Tunnels Prep Diagram provided in the start to this task, please fill in the blanks to complete the following ssh command.
Which syntax would properly setup a Remote tunnel from PC3 back to PC2 using PC3 SSH port as the target? (Max 2 Attempts)
A. ssh cctc@localhost -p 3333 -R 4444:localhost:22 -NT
B. ssh cctc@192.168.2.1 -R 4444:localhost:23 -NT
C. ssh -R 4444:localhost:22 cctc@192.168.2.1 -NT
D. ssh -R 4444:192.168.2.2:22 cctc@localhost -NT 
Answer: c

20. Tunnel Prep – Local to Remote. Using the Tunnels Prep Diagram provided in the start to this task, please fill in the blanks to complete the following ssh command.
Which syntax would properly setup a Local tunnel to map to the tunnel made in Question 19 using the tunnel made in Question 6 and Question 12? (Max 2 Attempts)
A. ssh cctc@localhost -p 2222 -L 5555:localhost:4444 -NT
B. ssh cctc@localhost -p 2222 -L 5555:100.1.1.1:4444 -NT
C. ssh -L 5555:localhost:4444 -p 2222 cctc@100.1.1.1 -NT
D. ssh -L 5555:192.168.2.2:22 -p 4444 cctc@100.1.1.1 -NT 
Answer: a







Task3
Mission Command will provide the IP Addresses to the following targets:
T3
T4
The Flag to commence Task 3 will be provided by Mission Command
Credentials for this environment are:
netY_studentX:passwordX
(netY = Networking Class Identifier & studentX = Student Number & passwordX = Student Number)
net3_student12
pasword12

1. Tunnels Training - Local Practice. T3 is the authorized initial pivot
Conduct passive recon on the Target T3, it appears to have access to the 10.3.0.0/24 subnet.
    Create a Local Port Forward from your Internet_Host to T3 targeting:
ip: 10.3.0.27
port: `HTTP``
Identify the flag on Victoria's HTTP Server


net3_student12@data-collection-net-ssh-01:~$ ssh student@10.50.34.177 -R 31200:localhost:22 -NT
student@internet-host-student-12:~$ ssh net3_student12@localhost -p 31200 -L 31201:192.168.0.20:3333 -NT
student@internet-host-student-12:~$ ssh net3_student12@localhost -p 31200 -L 31202:192.168.0.40:5555 -NT
student@internet-host-student-12:~$ ssh net3_student12@localhost -p 31202 -L 31203:172.16.0.60:23 -NT
net3_comrade12@data-collection-net-ssh-06:~$ ssh net3_student12@192.168.0.40 -p 5555 -R 31204:localhost:22 -NT
student@internet-host-student-12:~$ ssh net3_student12@localhost -p 31202 -L 31205:localhost:31204 -NT
student@internet-host-student-12:~$ ssh net3_comrade12@localhost -p 31205 -L 31206:172.16.0.90:2222 -NT
student@internet-host-student-12:~$ ssh net3_comrade12@localhost -p 31206 -D 9050
student@internet-host-student-12:~$ proxychains telnet 172.16.0.100


Scenario Credentials: FLAG = deep_deep_analysis

Attack Analysis Credentials: FLAG = cyb3r_nuk35




NFTABLES
nft add table [family] [table]
ntf add chain [family] [table] [chain] { type [type] hook [hook] priority [priority] \; policy [policy]\; }
net add rule [family] [table] [chain] [matches (matches)] 

example
sudo nft add table ip TABLE1
sudo nft add chain ip TABLE1 FILTER1 { type filter hook input priority 0 \; policy accept \; }
sudo nft add rule ip TABLE1 FILTER1 tcp sport {ssh, telnet, 3389, 6010-6050} ct state {new, established} accept 

sudo nft add chain ip Tthis_whole_ids_is_out_of_lineABLE1 FILTER2 { type filter hook output priority 0 \; policy accept \; }
sudo nft add rule ip TABLE1 FILTER2 tcp dport {ssh, telnet, 3389, 6010-6050} ct space {new, established} accept



how to change TTL
sudo iptables -t mangle -L
sudo iptables -t mangle -A POSTROUTING -j TTL --ttl-set 65
sudo iptables -t mangle -D POSTROUTING 1

Task 1 IP/NFTables - Host Filtering: T@bl3sth@tF1lt3r

IP/NFTables - Filtering T1
IPTable Rule Definitions
    Allow New and Established traffic to/from via SSH, TELNET, and RDP
    Change the Default Policy in the Filter Table for the INPUT, OUTPUT, and FORWARD chains to DROP
    Allow ping (ICMP) requests to and from the Pivot.
    Allow ports 6579 and 4444 for both udp and tcp traffic
    Allow New and Established traffic to/from via HTTP
Once these steps have been completed and tested, go to Pivot and open up a netcat listener on port 9001 and wait up to 2 minutes for your flag. If you did not successfully accomplish the tasks above, then you will not receive the flag.
T1
Hostname: BLUE_Host-1
IP: 172.16.82.106
Creds: student : password
Action: Implement Host Filtering to Allow and Restrict Communications and Traffic

sudo iptables -A INPUT -p tcp -m multiport --ports 22,23,80,3389 -m state --state NEW,ESTABLISHED -j ACCEPT
sudo iptables -A INPUT -s 10.10.0.40 -p icmp --icmp-type 8 -j ACCEPT
sudo iptables -A INPUT -s 10.10.0.40 -p icmp --icmp-type 0 -j ACCEPT
sudo iptables -A INPUT -d 10.10.0.40 -p icmp --icmp-type 8 -j ACCEPT
sudo iptables -A INPUT -d 10.10.0.40 -p icmp --icmp-type 0 -j ACCEPT
sudo iptables -A INPUT -p udp -p tcp -m multiport --ports 6579,4444
sudo iptables -A OUTPUT -p tcp -m multiport --ports 22,23,80,3389 -m state --state NEW,ESTABLISHED -j ACCEPT
sudo iptables -A OUTPUT -s 10.10.0.40 -p icmp --icmp-type 8 -j ACCEPT
sudo iptables -A OUTPUT -s 10.10.0.40 -p icmp --icmp-type 0 -j ACCEPT
sudo iptables -A OUTPUT -d 10.10.0.40 -p icmp --icmp-type 8 -j ACCEPT
sudo iptables -A OUTPUT -d 10.10.0.40 -p icmp --icmp-type 0 -j ACCEPT
sudo iptables -A OUTPUT -p udp -p tcp -m multiport --ports 6579,4444
sudo iptables -P INPUT DROP
sudo iptables -P OUTPUT DROP
sudo iptables -P FORWARD DROP


IP/NFTables - Filtering T3
IPTable Rule Definitions
    Allow New and Established traffic to/from via SSH, TELNET, and RDP
    Change the Default Policy in the Filter Table for the INPUT, OUTPUT, and FORWARD chains to DROP
    Allow New and Established traffic to/from via HTTP
Once these steps have been completed and tested, go to Pivot and open up a netcat listener on port 9003 and wait up to 2 minutes for your flag. If you did not successfully accomplish the tasks above, then you will not receive the flag.

sudo iptables -A INPUT -p tcp -m multiport --ports 22,23,80,3389 -m state --state NEW,ESTABLISHED -j ACCEPT
sudo iptables -P INPUT DROP
sudo iptables -P OUTPUT DROP
sudo iptables -P FORWARD DROP


Task 2 IP/NFTables - NAT: N@tF1lt3rsf0rL1f3

sudo shutdown -r 5


SNORT!
start snort
root@internet-host-student-12:/home/student# snort -D -l /var/log/snort/ -c /etc/snort/snort.conf

check to see if snort is running
root@internet-host-student-12:/home/student# ps -elf | grep snort
5 S root     13459     1  0  80   0 - 17157 x64_sy 13:46 ?        00:00:00 snort -D -l /var/log/snort/ -c /etc/snort/snort.conf
0 S root     13475 13443  0  80   0 -  1535 -      13:46 pts/1    00:00:00 grep snort

make sure that snort is logging
root@internet-host-student-12:/home/student# cd /var/log/snort
root@internet-host-student-12:/var/log/snort# ls
alert  snort.log.1688737570

read the alerts
cat alert

read the log file
root@internet-host-student-12:/var/log/snort# tcpdump -r snort.log.1688737570 -XXnvv

run snort against a pcap
root@internet-host-student-12:/etc/snort/rules# snort -r /home/activity_resources/pcaps/ids.pcap -c "normally use the config file. here, we specify a rule to use against the pcap"






Capstone / Review
START FLAG: crowning achievement
Floating IP of start pivot is: 10.50.40.226
student@internet-host-student-12:~$ ssh net3_student12@10.50.40.226 (password12)
net3_student12@capstone-01:~$ 
student@internet-host-student-12:/usr/share/cctc$ ls
autorun.sh  datagram_socket_receiver.py
student@internet-host-student-12:/usr/share/cctc$ ss -antl
State     Recv-Q    Send-Q       Local Address:Port        Peer Address:Port    
LISTEN    0         128                0.0.0.0:80               0.0.0.0:*       
LISTEN    0         128                0.0.0.0:22               0.0.0.0:*       
LISTEN    0         128                0.0.0.0:23               0.0.0.0:*       
LISTEN    0         128              127.0.0.1:6010             0.0.0.0:*       
LISTEN    0         128                   [::]:80                  [::]:*       
LISTEN    0         128                      *:21                     *:*       
LISTEN    0         2                    [::1]:3350                [::]:*       
LISTEN    0         128                   [::]:22                  [::]:*       
LISTEN    0         128                  [::1]:6010                [::]:*       
LISTEN    0         2                        *:3389                   *:*  

To answer these 4 questions, you will need to use tcpdump and BPF's against the capstone-bpf.pcap file.


-------------------------------------------------------------------------------

Question 1:
Using BPF’s, determine how many packets with a DSCP of 26 being sent to the host 10.0.0.103.
Provide the number of packets converted to BASE64.
net3_student12@capstone-02:/usr/share/cctc$ tcpdump -n -r capstone-bpf.pcap "dst host 10.0.0.103 && ip[1] >> 2 = 26" | wc -l
reading from file capstone-bpf.pcap, link-type EN10MB (Ethernet)
108

-------------------------------------------------------------------------------

Question 2:
What is the total number of fragmented packets?
Provide the number of packets converted to BASE64.
net3_student12@capstone-02:/usr/share/cctc$ tcpdump -n -r capstone-bpf.pcap "((ip[6:2] > 0) and (not ip[6] = 64))" | wc -l
reading from file capstone-bpf.pcap, link-type EN10MB (Ethernet)
2729

-------------------------------------------------------------------------------

Question 3:
How many packets have the DF flag set and has ONLY the RST and FIN TCP Flags set?
Provide the number of packets converted to BASE64.
net3_student12@capstone-02:/usr/share/cctc$ tcpdump -n -r capstone-bpf.pcap "ip[6]&0x40!=0 && tcp[13]=5" | wc -l
reading from file capstone-bpf.pcap, link-type EN10MB (Ethernet)
109

-------------------------------------------------------------------------------

Question 4:
An attacker is targeting the host 10.0.0.104 with either a TCP full or half open scan. Based off the pcap, how many ports are open?
Provide the number of ports converted to BASE64.
net3_student12@capstone-02:/usr/share/cctc$ tcpdump -n -r capstone-bpf.pcap "src host 10.0.0.104 && tcp[13]=18" | wc -l
reading from file capstone-bpf.pcap, link-type EN10MB (Ethernet)
18

-------------------------------------------------------------------------------

tcp listening port waiting for connections
python3 tcp stream sender and send it through tunnel to say Hi
message as bytes-like object and decode the response to/from UTF-8 to get encoded message

net3_student12@capstone-01:~$ echo "proxychains scp tgt@192.168.1.10:/home/tgt/secret.txt ." | base64

10.50.39.13/32

netN_comradeX
Netflix.and.Chill
net3_student12@capstone-01:~$ echo "Netflix and Chill" | base64
TmV0ZmxpeCBhbmQgQ2hpbGwK

1) make sure to change iptables to look like a cicso device

2) student@internet-host-student-12:~$ ssh net3_student12@10.50.39.13 -p 7777 -L 31200:10.2.2.6:7777 -NT

3) student@internet-host-student-12:~$ ssh net3_student12@localhost -p 31200 -L 31201:10.2.2.7:23 -NT

4) from IH telnet localhost 31201

5) net3_comrade12@capstone-07:~$ ssh net3_student12@10.2.2.6 -p 7777 -R 31202:localhost:2222 -NT

6) student@internet-host-student-12:~$ ssh net3_student12@localhost -p 31200 -L 31203:localhost:31202 -NT

7) student@internet-host-student-12:~$ ssh -p 31203 net3_comrade12@localhost -L 31204:10.10.10.140:301 -NT

8) student@internet-host-student-12:~$ ssh -p 31204 net3_student12@localhost -D 9050

9) net3_student12@capstone-12:~$  ip addr (to get ip and cidr)

10) student@internet-host-student-12:~$ proxychains ./scan.sh net 192.168.1 start 96 end 127 ports 21-23 80

11) student@internet-host-student-12:~$ proxychains wget -r ftp://192.168.10.111

12) student@internet-host-student-12:~$ proxychains ssh net3_student12@192.168.10.101

13) net3_student12@capstone-13:~$ cd /usr/share/cctc
net3_student12@capstone-13:/usr/share/cctc$ ls
capstone-analysis_HEX-ENCODED.pcap  Flag-13f.txt

14a) student@internet-host-student-12:~$ proxychains scp net3_student12@192.168.10.101:/usr/share/cctc/capstone-analysis_HEX-ENCODED.pcap .
14b) student@internet-host-student-12:~$ xxd -r capstone-analysis_HEX-ENCODED.pcap capstone.pcap
14c) student@internet-host-student-12:~$ wireshark

14d) net3_student12@capstone-13:/usr/share/cctc$ cat Flag-13f.txt 
To answer these 8 questions, you will need extract the capstone-analysis-HEX-Encoded.pcap file that you will need extract, decode with XXD, and open with Wireshark.
-------------------------------------------------------------------------------
Question 1:
Which ip address initiated the attack against the FTP server? 10.1.0.108
Provide the ip address in the x.x.x.x format and converted to Base64.
-------------------------------------------------------------------------------
Question 2:
How many failed attempts to guess the FTP password? 4
Provide number and converted to Base64.
-------------------------------------------------------------------------------
Question 3:
What is the correct FTP password? w
Provide the exact password and converted to Base64.
-------------------------------------------------------------------------------
Question 4:
What is the system IP that was compromised? 10.2.0.2
Provide the ip address in the x.x.x.x format and converted to Base64.
-------------------------------------------------------------------------------
Question 5:
What is the FTP version? 3.0.2
Provide the version number only and converted to Base64.
-------------------------------------------------------------------------------
Question 6:
What is the name of the file taken by the attacker? test.txt
Provide the filename exactly as shown and converted to Base64.
-------------------------------------------------------------------------------
Question 7:
What was the message contained within the extracted file? ftp-data hi
Provide the message exactly as shown and converted to Base64.
-------------------------------------------------------------------------------
Question 8:
What is the name of the file uploaded by the attacker? company_payroll_2019
Provide the filename exactly as shown and converted to Base64.
-------------------------------------------------------------------------------


net3_student12@capstone-14:/usr/share/cctc$ cat Flag-14f.txt 
To answer these s questions, you will need to examine the Snort services running on this system.
-------------------------------------------------------------------------------
Question 1:
How many rule files are on the system?
Provide the number converted to Base64 as your answer.
-------------------------------------------------------------------------------
Question 2:
How many of the rules are currently in use to match on traffic?
Provide the number converted to Base64 as your answer.
-------------------------------------------------------------------------------
Question 3:
Which rule will look for someone doing a null scan ?
Provide only the filename as your answer (i.e. ‘file.rules’) and converted to Base64.
-------------------------------------------------------------------------------
Question 4:
What is the exact Alert Message that is being triggered on the system?
Convert the exact message as you see it and convert it to Base64 for your answer.
---------------------------------------------------------------
Question 5:
From what IP is the attack coming from?
Provide your answer in the x.x.x.x format and converted to Base64.

-------------------------------------------------------------------------------


scan.sh
#!/bin/bash
echo "Enter network address (e.g. 192.168.0): "
read net
echo "Enter starting host range (e.g. 1): "
read start
echo "Enter ending host range (e.g. 254): "
read end
echo "Enter ports space-delimited (e.g. 21-23 80): "
read ports
for ((i=$start; $i<=$end; i++))
do
    nc -nvzw1 $net.$i $ports 2>&1 | grep -E 'succ|open'
done
# (-v) running verbosely (-v on Linux, -vv on Windows),
# (-n) not resolving names. numeric only IP(no D.S)
# (-z) without sending any data. zero-I/O mode(used for scanning)
#(-w1) waiting no more than 1second for a connection to occur
# (2>&1) redirect STDERR to STDOUT. Results of scan are errors and need to redirect to output to grep
# (-E) Interpret PATTERN as an extended regular expression
# ( | grep open) for Debian to display only open connections
# ( | grep succeeded) for Ubuntu to display only the open connections




[10:38 AM] Bochner, Randy J WO1 USARMY 780 MI BDE (USA)

#########################

#Find Stuffz

#########################

find / -type f -exec grep -l "687-250" {} + 2>/dev/null    #search the contents of all files for a string

find / -type d -name "*687-250*"    #search all directories for a string

find / -type f -name ".*"   #find hidden files 

find / -type d -name ".*"   #find hidden directories

find / -type f -perm -4000 | xargs ls -la  #find all files with the SUID bit set

find / -inum 74653   # find all files with associated inode number

find / -samefile /usr/bin/dispuid   #find all files that are the same  (same inode)

find / -executable -type f -perm -2000 2>/dev/null | wc -l

find / -type f -perm -2000 2>/dev/null | wc -l 

find / -type f -name ".*" -exec ls -latriQ {} 2>/dev/null +   #find hidden files 

find / -type d -name ".*" -exec ls -ladtri {} 2>/dev/null +   #find hidden directories 

find / -type d -name " *" -exec ls -ladtri {} 2>/dev/null +  #find directories with a space 

find / -type f -name " *" -exec ls -latriQ {} 2>/dev/null +   #find files with a space

[10:39 AM] Bochner, Randy J WO1 USARMY 780 MI BDE (USA)

pro tip for FORGE, the Q in ls -latriQ quotes the file, so you can see if the filename has a space in it

[10:40 AM] Bochner, Randy J WO1 USARMY 780 MI BDE (USA)

a lot of malware likes to hide like that


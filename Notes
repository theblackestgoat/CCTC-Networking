https://net.cybbh.io/public/networking/latest/index.html
http://10.50.20.162:8000/
ROCR-002-W

All of the things in one place:
https://miro.com/app/board/o9J_klSqCSY=/

ssh -X student@ 10.50.34.177
X allows for GUI-based programming

1. To view your IP address and interface information:
        a. current =        ip address (ip addr)
        b. deprecated =     ifconfig

    2. To view your ARP cache:
        a. current =        ip neighbor (ip nei)
        b. deprecated =     arp -a

    3. To view open TCP and UDP sockets:
        a. current = 
            i. TCP =        ss -antlp
            ii. UDP =       ss -anulp
        b. deprecated =     netstat

    4. To view active processes:
        a. static =         ps -elf
        b. real-time =      top or htop

    5. To open file manager from the command line or X11 connection:
        a. nautilus
        b. pcmanfm

    6. Web Browsers:
        a. Firefox
        b. Chromium
        c. Konqueror

    7. To open images from the command line or X11 connection:
        a. Eye of Gnome =                   eog [file]
        b. Nomacs =                         nomacs [file]
        c. Eye of Mate =                    eom [file]
        d. GNU Image Manipulation Program = gimp [file]

    8. Network scanning:
        a. nmap
            -sT = TCP Full connection
            -sS = TCP SYN scanning
            -Pn = Disable ping sweep
            -sU = UDP scanning
        b. zenmap
        c. netcat
            TCP: nc -nzvw1 10.10.0.40 21-23 80
            UDP: nc -unzvw1 10.10.0.40 53 69
        d. ping
        e. traceroute

    9. Network Utilization:
        a. iftop
        b. iptraf-ng

    10. Packet Manipulation (requires root privileges):
        a. scapy
        b. hping3
        c. yersinia     yersinia -G

    11. Packet Sniffing (requires root privileges):
        a. Wireshark
        b. tcpdump
        c. p0f
        d. tshark

    12. Banner Grabbing:
        a. netcat
            Client: nc 10.10.0.40 22
            Listener: nc -lvp 1234
        b. telnet
            telnet 10.10.0.40
        c. wget
            wget -r http://10.10.0.40
            wget -r ftp://10.10.0.40
        d. curl
            curl http://10.10.0.40
            curl ftp://10.10.0.40

    13. DNS Query:
        a. whois
        b. dig
            Records:
                A - IPv4
                AAAA - IPv6
                NS - Name Server
                SOA - Start of Authority
                MX - Mail Server
                TXT - Human readable message

    14. Remote access:
        a. ssh
            ssh student@10.10.0.40
            ssh student@10.10.0.40 -p 2222
        b. telnet
            telnet 10.10.0.40
            telnet 10.10.0.40 23

    15. File Transfer:
        a. scp
            scp student@10.10.0.40:file .
            scp file student@10.10.0.40Host Discovery: 

Nmap Scan: 
nmap -sn <ip_range_>/24 

ARP Scan: 
Works if on the same subnethttps://miro.com/app/board/o9J_klSqCSY=/
sudo nmap - PR -sn <targetIP> 

ARP-Scan: 
sudo arp-scan  --localnet 
sudo arp-scan -I eth0 -l 

Ping Scan: 
nmap -PE -sn <targetIP/24> 

TCP SYN Ping: 
sudo nmap -PS -sn <targetIP/24> 

TCP ACK Ping: 
sudo nmap -PA -sn <targetIP/24> 

UDP Ping:  
sudo nmap -PU -sn <targetIP/24> 

MassScan: 
masscan MACHINE_IP/24 -p443 
masscan MACHINE_IP/24 -p80,443 
masscan MACHINE_IP/24 -p22-25 
masscan MACHINE_IP/24 ‐‐top-ports 100 

NetDiscover: 
netdiscover -r <IP_RANGE>/24     ---> Returns MACs, Hostnames :
        b. netcat
            nc 10.10.0.40 1234 < file
            nc -lvp 1234 > file

Host Discovery: 
Nmap Scan: 
nmap -sn <ip_range_>/24 

ARP Scan: 
Works if on the same subnet 
sudo nmap - PR -sn <targetIP> 

ARP-Scan: 
sudo arp-scan  --localnet 
sudo arp-scan -I eth0 -l 

Ping Scan: 
nmap -PE -sn <targetIP/24> 

TCP SYN Ping: 
sudo nmap -PS -sn <targetIP/24> 

TCP ACK Ping: 
sudo nmap -PA -sn <targetIP/24> 

UDP Ping:  
sudo nmap -PU -sn <targetIP/24> 

MassScan: 
masscan MACHINE_IP/24 -p443 
masscan MACHINE_IP/24 -p80,443 
masscan MACHINE_IP/24 -p22-25 
masscan MACHINE_IP/24 ‐‐top-ports 100 
NetDiscover: 
netdiscover -r <IP_RANGE>/24     ---> Returns MACs, Hostnames 

CTF Scans: 
TCP: 
sudo nmap -p- -A -vv 10.10.220.206 -oN ~/TCP_recon.nmap -T4 --min-rate 1000 --max-retries 3 
UDP:  
sudo nmap -p- -sU -vv <targetIP> -oN ~/UDP_recon.nmap -T4 --min-rate 1000 --max-retries 3 

Basic Port Scans 
Port Scan Type Example Command 
TCP Connect Scan nmap -sT 10.10.149.197 
TCP SYN Scan sudo nmap -sS 10.10.149.197 
UDP Scan sudo nmap -sU 10.10.149.197 

Option Purpose 
-p- all ports 
-p1-1023 scan ports 1 to 1023 
-F 100 most common ports 
-r scan ports in consecutive order 
-T<0-5> -T0 being the slowest and T5 the fastest 
--max-rate 50 rate <= 50 packets/sec 
--min-rate 15 rate >= 15 packets/sec 
--min-parallelism 100 at least 100 probes in parallel 
Option Meaning 
-sV determine service/version info on open ports 
-sV --version-light try the most likely probes (2) 
-sV --version-all try all available probes (9) 
-O detect OS 
--traceroute run traceroute to target 
--script=SCRIPTS Nmap scripts to run 
-sC or --script=default run default scripts 
-A equivalent to -sV -O -sC --traceroute 
-oN save output in normal format 
-oG save output in grepable format 
-oX save output in XML format 
-oA save output in normal, XML and Grepable formats 
-oS save output in Script Kiddie format 

Netbios Scan Techniques: 
nmap -p netbios*,microsoft-ds [target host] 
sudo nmap -sU -sS -p U:137-139,T:137-139,445 [target host] 
sudo nmap -sU -sS -p netbios*,microsoft-ds [target host] 

Advanced Port Scans 
Port Scan Type Example Command 
TCP Null Scan sudo nmap -sN 10.10.90.13 
TCP FIN Scan sudo nmap -sF 10.10.90.13 
TCP Xmas Scan sudo nmap -sX 10.10.90.13 
TCP Maimon Scan sudo nmap -sM 10.10.90.13 
TCP ACK Scan sudo nmap -sA 10.10.90.13 
TCP Window Scan sudo nmap -sW 10.10.90.13 
Custom TCP Scan sudo nmap --scanflags URGACKPSHRSTSYNFIN 10.10.90.13 
Spoofed Source IP sudo nmap -S SPOOFED_IP 10.10.90.13 
Spoofed MAC Address --spoof-mac SPOOFED_MAC 
Decoy Scan nmap -D DECOY_IP,ME 10.10.90.13 
Idle (Zombie) Scan sudo nmap -sI ZOMBIE_IP 10.10.90.13 
Fragment IP data into 8 bytes -f 
Fragment IP data into 16 bytes -ff 

Option Purpose 
--source-port PORT_NUM specify source port number 
--data-length NUM append random data to reach given length 
--reason explains how Nmap made its conclusion 
-v verbose 
-vv very verbose 
-d debugging 
-dd more details for debugging 

netstat
ss -antl

# once you have ssh into the INTERNET_HOST box:
$ terminator
$ pcmanfm
  opens a gui to navigate the file structure

1. ARP Storm. What MAC address is initiating the ARP Storm?
ws filter: arp
look for a mac blasting out a bunch of arp requests
Answer: 00:07:0d:af:f4:54

2. ARP – 1. What is the MAC of 10.10.10.1?
ws filter: ip.addr == 10.10.10.1
look at the source to find the mac
Answer:  00:1d:09:f0:92:ab

3. ARP – 2. What is the MAC of 10.10.10.2?
ws filter: ip.addr == 10.10.10.2
look at the source to find the mac
Answer: 00:1a:6b:6c:0c:cc

4. ARP – 3. What is the MAC address of the system trying to perform the ARP MitM attack?
ws filter: arp
fa:16:3e:35:21:5a is claiming multiple ip addresses
Answer: fa:16:3e:35:21:5a

5. RARP – 1. What is the OP code of a RARP Request?
https://www.iana.org/assignments/arp-parameters/arp-parameters.xhtml#arp-parameters-1
Answer: 3

6. RARP – 2. What is the OP code of a RARP Response?
Answer: 4

7. RARP – 3. What is the RARP requestor’s MAC?
Answer: 00:0c:29:34:0b:de

8. RARP – 4. What was the RARP requestor’s resolved IP address?
Answer: 10.1.1.100

9. Gratuitous ARP – 1. What is the MAC of the system spamming gratuitous ARP’s for 192.168.1.254?
look for gratuitous arp requests in info
Answer: 00:00:5e:00:01:01

10. CDP – 1. What is the software version of the Cisco Switch (copy entire field “as is” from Wireshark)?
ws filter: cdp
Answer: IOS (tm) C2950 Software (C2950-I6K2L2Q4-M), Version 12.1(22)EA14, RELEASE SOFTWARE (fc1)

11. CDP – 2. What is the software version of the Cisco Router (copy entire field “as is” from Wireshark)?
ws filter: cdp
Answer: IOS (tm) 1600 Software (C1600-NY-L), Version 11.2(12)P, RELEASE SOFTWARE (fc1)

12. LLDP – 1. What is the System Name of one of the LLDP sending devices?
ws filter: lldp
answer: S1.cisco.com

13. STP – 1. What is the Bridge Priority of the STP Root Bridge?
ws filter: stp
look in spanning tree protocol dropdown
Answer: 0

14. STP – 2. What is the MAC address of the STP Root Bridge?
Answer: 00:1f:27:b4:7d:80

15. VTP – 1. What is the VTP Management Domain Name?
Answer: cicso

16. VTP – 2. What is the latest configuration revision number?
Answer: 11

17. VTP – 3. How many total VLANs are being advertised via VTP?
Answer: 22

18. VLAN – 1. What is the message contained within the single tagged VLAN traffic coming from 11.22.33.44?
filter for the ip and follow tcp stream
Answer: I pitty the foo

19. VLAN – 2. What is the VLAN ID of this traffic?
Answer: 999

20. VLAN Hopping – 1. What is the VLAN ID being attacked by 10.10.10.10 using Double Tagging?
250

21. VLAN Hopping – 2. What is the combined message being sent via ICMP?
Answer: Wouldn't you like too be a Pepper Too!

22. ICMP – 1. What is the OS of 192.168.1.1 host based off its Echo Request message to the Google DNS?
TTL = 64
Answer: linux

23. ICMP – 2. What is the message that 192.168.65.20 sending to Google's DNS via ICMP?
Answer: Exsqueeze me?

24. ICMP – 3. How many Hops away is the 151.101.64.84 address?
Answer: 11

25. Fragmented – 1. What is the IP ID of the fragmented ICMP packet? (starting at packet 6472)
Answer: 46544

26. Fragmented – 2. What is the offset value of the fragments?
    Not the calculated value shown in Wireshark
    Suggest converting the value from the Hex Dump
Answer: 122

27. Fragmented – 3. What is the possible OS of the system that sent this ICMP based on the message payload?
Answer: windows

28. ICMPv6 – 1. What is the ICMPv6 type number of Echo Request?
Answer: 128

29. ICMPv6 – 2. What is the ICMPv6 type number of Echo Reply?
Answer: 129

30. ICMPv6 – 3. What is the ICMPv6 type number of the Router Advertisement message?
134

31. ICMPv6 – 4. What is the link-layer address of the advertising router?
Answer: fa:16:3e:35:21:5a

32. ICMPv6 – 5. What is the IPv6 prefix being advertised?
Answer: beef:4:f00d::

33. HSRP – 1. What is the HSRP virtual IP?
Answer: 192.168.0.1

34. HSRP – 2. What is the HSRP multicast address used?
Answer: 224.0.0.2

35. HSRP – 3. What is the IP address of the HSRP Active forwarder (before the takeover)?
Answer: 192.168.0.30

36. HSRP – 4. What is the IP address of the HSRP Active forwarder (after the takeover)?
Answer: 192.168.0.10

37. VRRP – 1. What is the VRRP multicast address used?
Answer: 224.0.0.18

38. VRRP – 2. What is the VRRP virtual IP?
Answer: 192.168.1.254

39. VRRP – 3. How many total devices are communicating via VRRP?
Answer: 3

40. RIP – 1. How many networks are being advertised via RIP?
Answer: 2

41. RIP – 2. What are the networks being advertised (in numeric order separated by commas and no spaces)?
(i.e. 1.0.0.0,2.0.0.0 )
Answer: 200.0.1.0,200.0.2.0

42. RIP – 3. What Protocol and port is being used for RIP?
Transport PROTOCOL PORT
Answer: UDP 520

43. EIGRPv4 – 1. What network is being advertised via EIGRPv4
Answer: 192.168.4.0/24

44. EIGRPv4 – 2. What is the IP protocol number used for EIGRP?
Answer: 88

45. EIGRPv4 – 3. What multicast address is used to send EIGRPv4 updates?
Answer: 224.0.0.10

46. EIGRPv6 – 1. What network is being advertised via EIGRPv6
Answer: 2001:db8:0:400::/64

47. EIGRPv6 – 2. What multicast address is used to send EIGRPv6 updates?
Answer: ff02::a

48. EIGRPv6 – 3. What Autonomous system number is being used?
Answer: 100

49. OSPF – 1. What is the IP protocol number used for OSPF?
Answer: 89

50. OSPF – 2. What is the IP address of the OSPF designated router (DR)?
Answer: 192.168.170.8

51. OSPF – 3. What multicast address is used by the DR to send updates?
Answer: 224.0.0.5

52. BGP – 1. How many networks are being advertised via BGP?

54. BGP – 3. What Autonomous system number is the 192.168.0.10 peer in?
Answer: 62510 

55. BGP – 4. What Protocol and port is being used for BGP?
Transport PROTOCOL PORT
Answer: TCP 179

52. BGP – 1. How many networks are being advertised via BGP?
Answer: 3

53. BGP – 2. What are the networks being advertised (in numeric order separated by commas and no spaces)?
(i.e. 1.0.0.0,2.0.0.0)
Answer: 10.0.0.0/8,172.16.0.0/16,192.168.4.0/22

Wh@t_P@load?

1. SMB – 1. What Protocol and port is being used for SMB?
PROTOCOL PORT
Answer: TCP 445

2. SMB – 2. What is the name of the file accessed via SMB?
    Follow the stream
Answer: putty.exe

3. DHCP – 1. What is the IP address of the DHCP server?
ws filter: bootp
Answer: 192.168.0.1

4. DHCP – 2. What is the “offered” IP address?
Answer: 192.168.0.10

5. DHCP – 3. What is the DHCP lease time (in seconds)?
Answer: 3600

6. DNS – 1. What ".com" webpage was the “A” record requested for?
Answer: microsoft.com

7. DNS – 2. What webpage was the “AAAA” record requested for?
Answer: wikipedia.org

8. DNS – 3. What mail server was the “MX” record requested for?
Answer: hotmail.com

9. DNS – 4. What domain was the Zone transfer requested for?
Answer: etas.com

10. FTP – 1. What is the username/password used for the FTP authentication?
Answer: student10/password10

11. FTP – 2. What was the filename requested via FTP?
Answer: DO_NOT_LOOK.txt

12. FTP – 3. What was the message in the file transferred via FTP?
Answer: Schrodinger's Cat

13. FTP – 4. What was the source and destination ports used for the Passive FTP (SPORT:DPORT)?
Answer: 42452:38591

14. HTTP – 1. What was the HTTP site reached (without any errors or redirects)?
Answer: www.faqs.org

15. HTTP – 2. What was the HTTP site that was “Moved Temporarily”?
Answer: https://snippets.cdn.mozilla.net/us-west/bundles/bundle_6fdbf7e26c281d58ce9687293f922ec1607595bb.json

16. HTTP – 3. What was the HTTP site that was “Moved Permanently”?
Answer: http://msn.com/

17. HTTP – 4. What was the HTTPs (TLS) site that was reached?
Answer: twitter.com

18. SMTP – 1. What is the SMTP domain name?
(i.e. domain.com )
Answer: virginmedia.com

19. SMTP – 2. Who sent the email to (cuizw@public.qd.sd.cn)?
Answer: owadomyi2897@virginmedia.com

20. SMTP – 3. From the message, what are “self-explanatory”?
Answer: sizes

21. SMTP – 4. What is the name of the SMTP server communicating over IPv6?
Answer: mx.google.com

22. IMAP – 1. What is the username that signed-in via IMAP?
Answer: LOGIN "neulingern" "XXXXXX"

23. IMAP – 2. How many emails were “fetched”?
Answer: Jerry Hammons

25. POP – 1. What is the POP mailbox address?
Answer: digitalinvestigator@networksims.com

26. POP – 2. How many messages does this mailbox have?
Answer: 3

27. POP – 3. What is the name of the University in one of the email messages?
Answer: Edinburgh Napier University

28. NTP – 1. What is the IP of the NTP server?
Answer: 192.168.50.50

29. NTP – 2. What is the Timestamp in the NTP messages (MONTH DAY, YEAR)?
Answer: Sep 27, 2004 03:18:04.922896299 UTC

30. NTP – 3. What is the NTP version number?
Answer: 3

31. SSH – 1. What is the SSH server IP address?
Answer: 172.16.40.10

32. SSH – 2. What is the SSH protocol version being used by both (copy entire field “as is” from Wireshark)?
Answer: SSH-2.0-OpenSSH_7.9p1 Debian-10+deb10u2

33. SSH – 3. Which asymmetric encryption protocol is being used?
Answer: diffie-hellman

34. SSH – 4. What is the MSS option set to for the SSH communication?
    MSS can be found in the SYN exchange.
Answer: 1410

35. SSH – 5. What is the windows scale shift option set to?
    Windows scale can be found in the SYN exchange.
Answer: 7

36. TELNET – 1. What is the username/password of the account used via telnet?
Answer: fake/user

37. TELNET – 2. What is the exact first command issued on the remote system over telnet?
Answer: /sbin/ping www.yahoo.com

38. TELNET – 3. What was the second command issued?
Answer: ls

39. TELNET – 4. What is the inital sequence number of the client?
    suggest to convert the Hexdump to Decimal
Answer: 2579865836

40. TELNET – 5. What is the MSS of the server?
Answer: 1448

41. RADIUS – 1. What was the username used to log in via RADIUS
Answer: John.McGuirk

42. RADIUS – 2. What is the RADIUS Request code?
Answer: 1

43. RADIUS – 3. What is the RADIUS Accept code?
Answer: 2

44. RADIUS – 4. What is the RADIUS Challenge code?
Answer: 11

45. TACACS+ – 1. What is the IP of the TACACS+ server?
Answer: 192.168.1.5

46. TACACS+ – 2. What is the SPORT used for the communication?
Answer: 59087

47. TACACS+ – 3. What is the MSS option set to for the TACACS+ communication?
Answer: 1460

48. TACACS+ – 4. What is the starting window size of the TACACS+ client?
Answer: 4128

49. SNMP – 1. What SNMP version is being used?
Answer: 3

50. SNMP – 2. What is the IPv4 address of the SNMP server?
    It will be the system doing the get-request
Answer: 10.0.0.150

51. SNMP – 3. What is the IPv6 address of the SNMP server?
    It will be the system doing the get-request
Answer:2001:470:e5bf:1001:1cc7:73ff:65f5:a2f7

52. SNMP – 4. What Protocol and port is being used for SNMP communication?
PROTOCOL PORT
Answer: UDP 161

53. TFTP – 1. What is the IP address of the TFTP server?
Answer: 192.168.0.13

54. TFTP – 2. What is the name of the file uploaded to the TFTP server?
Answer: rfc1350.txt

55. TFTP – 3. How many TFTP “Blocks” were used to send the file?
Answer: 49

TCPDUMP
sudo tcpdump -i eth0 -XXvnn -w file.pcap
sudo tcpdump -r file.pcap

N3tw0rkBPF

Basic Analysis - ttl. What is the Berkeley Packet Filter, using tcpdump, to capture all packets with a ttl of 64 and less, utilizing the IPv4 or IPv6 Headers? There should be 8508 packets.
Enter the Filter syntax with no spaces
$ sudo tcpdump 'ip[8] <= 64 || ip6[7] <= 64' -r BPFCheck.pcap | wc -l
ip[8] refers to the TTL field within the IPv4 header. The TTL field is located at byte offset 8 in the IP header.
ip6[7] refers to the Hop Limit field within the IPv6 header. The Hop Limit field is located at byte offset 7 in the IPv6 header.
The expression <= 64 checks if the TTL or Hop Limit is less than or equal to 64, which matches packets with a TTL value of 64 and lower.
Answer: ip[8]<=64||ip6[7]<=64

Basic Analysis - dont fragment. What is the Berkeley Packet Filter, using tcpdump, to capture all IPv4 packets with at least the Dont Fragment bit set? There should be 2321 packets.
tcpdump -i <interface> 'ip[6] & 0x4000 != 0'
Let's break down the filter expression:
ip[6] refers to the 7th byte (offset 6) in the IPv4 header, which contains the "Flags" field.
& 0x4000 performs a bitwise AND operation with the value 0x4000, which corresponds to the DF bit.
!= 0 checks if the result of the bitwise AND operation is not equal to 0, indicating that the DF bit is set.
sudo tcpdump 'ip[6] & 0x40 != 0' -r BPFCheck.pcap | wc -l
Answer: ip[6]&0x40!=0

Basic Analysis - high port. What is the Berkeley Packet Filter, using tcpdump, to capture traffic with a Source Port higher than 1024, utilizing the correct Transport Layer Headers? There should be 7805 packets.
tcpdump -i <interface> '((tcp[0:2] > 1024) or (udp[0:2] > 1024))'
tcp[0:2] represents the first two bytes of the TCP header, which include the source port field.
udp[0:2] represents the first two bytes of the UDP header, which also include the source port field.
> is the greater-than operator.
1024 is the value representing the port number threshold
sudo tcpdump '((tcp[0:2] > 1024) || (udp[0:2] > 1024))' -r BPFCheck.pcap | wc -l
Answer: tcp[0:2]>1024||udp[0:2]>1024

Basic Analysis - udp. What is the Berkeley Packet Filter, using tcpdump, to capture all Packets with UDP protocol being set, utilizing the IPv4 or IPv6 Headers? There should be 1277 packets.
sudo tcpdump 'udp' -r BPFCheck.pcap | wc -l (while this works, it doesn't specify which bit/byte to use to reference "protocol"
sudo tcpdump 'ip[9] = 17 || ip6[6] = 17' -r BPFCheck.pcap | wc -l
For IPv4:
ip[9] refers to the 10th byte (offset 9) in the IPv4 header, which contains the "Protocol" field.
= 17 checks if the value of the "Protocol" field is equal to 17, which corresponds to the UDP protocol.
For IPv6:
ip6[6] refers to the 7th byte (offset 6) in the IPv6 header, which contains the "Next Header" field.
= 17 checks if the value of the "Next Header" field is equal to 17, which corresponds to the UDP protocol.
Answer: ip[9]=17||ip6[6]=17

Basic Analysis - tcp flags. What is the Berkeley Packet Filter, using tcpdump, to capture only packets with the ACK/RST or ACK/FIN flag set, utilizing the correct Transport Layer Header? There should be 1201 packets.
tcpdump -i <interface> 'tcp[13] & 0x15 != 0'
Let's break down the filter expression:
tcp[13] refers to the 14th byte (offset 13) in the TCP header, which contains the TCP flags field.
& 0x15 performs a bitwise AND operation with the value 0x15, which corresponds to the combination of the ACK and RST or ACK and FIN flags.
!= 0 checks if the result of the bitwise AND operation is not equal to 0, indicating that either the ACK/RST or ACK/FIN flags are set.
sudo tcpdump 'tcp[13]=20||tcp[13]=17' -r BPFCheck.pcap | wc -l
Answer: tcp[13]=20||tcp[13]=17

Basic Analysis - id. What is the Berkeley Packet Filter, using tcpdump, to capture all packets with an IP ID field of 213? There should be 10 packets.
sudo tcpdump 'ip[4:2] = 213' -r BPFCheck.pcap | wc -l 
ip[4:2] refers to bytes 5 and 6 (offset 4 to 5) in the IP header, which contain the IP ID field.
= 213 checks if the value of the IP ID field is equal to 213.
Answer" ip[4:2]=213

Basic Analysis - vlan. What is the Berkeley Packet Filter, using tcpdump, to capture all traffic that contains a VLAN tag? There should be 182 packets.
sudo tcpdump 'vlan' -r BPFCheck.pcap | wc -l (this works but isn't the right answer)
sudo tcpdump 'ether proto 0x8100' -r BPFCheck.pcap | wc -l (this also works but isn't the right answer)
ether proto 0x8100 specifies the Ethernet protocol field (EtherType) as 0x8100, which indicates the presence of a VLAN tag using the 802.1Q frame format.
sudo tcpdump 'ether[12:2] = 0x8100' -r BPFCheck.pcap | wc -l
ether[12:2] refers to bytes 13 and 14 (offset 12 to 13) in the Ethernet header, which contain the EtherType field.
= 0x8100 checks if the value of the EtherType field is equal to 0x8100, which indicates the presence of a VLAN tag using the 802.1Q frame format.
Answer: ether[12:2]=0x8100

Basic Analysis - dns. What is the Berkeley Packet Filter, using tcpdump, to capture all IPv4 packets relating to DNS? There should be 63 packets.
sudo tcpdump 'tcp[2:2]=53||tcp[0:2]=53||udp[2:2]=53||udp[0:2]=53' -r BPFCheck.pcap | wc -l 
Answer: tcp[2:2]=53||tcp[0:2]=53||udp[2:2]=53||udp[0:2]=53

Basic Analysis - CLIENT CONNECTIONS. What is the Berkeley Packet Filter, using tcpdump, to capture the initial packets from a client trying to initiate a TCP connection? There should be 3447 packets
tcpdump -i <interface> 'tcp[13] & 2 != 0 and tcp[13] & 16 = 0' (this does not give the right answer)
tcp[13] & 2 != 0 checks if the 14th byte (offset 13) in the TCP header has the second bit (SYN flag) set. This filters for packets that contain the SYN flag, indicating a request to establish a TCP connection.
tcp[13] & 16 = 0 checks if the 14th byte (offset 13) in the TCP header has the fifth bit (ACK flag) unset. This filters for packets where the ACK flag is not set, indicating the initial packet of the TCP handshake.
Answer: sudo tcpdump 'tcp[13]=2' -r BPFCheck.pcap | wc -l

Basic Analysis - OPEN PORTS. What is the Berkeley Packet Filter, using tcpdump, to capture the response packets from a server listening on an open TCP ports? There should be 277 packets
tcpdump -i <interface> 'tcp[13] & 2 = 2 and tcp[13] & 18 = 18'
tcp[13] & 2 = 2 checks if the 14th byte (offset 13) in the TCP header has the second bit (SYN flag) set. This filters for packets that have the SYN flag turned on.
tcp[13] & 18 = 18 checks if the 14th byte (offset 13) in the TCP header has both the second bit (SYN flag) and the fourth bit (ACK flag) set. This filters for packets that have both the SYN and SYN+ACK flags turned on.
Answer: tcp[13]=18

Basic Analysis - CLOSED PORTS. What is the Berkeley Packet Filter, using tcpdump, to capture the response packets from a server with closed TCP ports There should be 17 packets
Answer: tcp[13]=4

Basic Analysis - WELL KNOWN PORTS.What is the Berkeley Packet Filter, using tcpdump, to capture all TCP and UDP packets sent to the well known ports? There should be 3678 packets
sudo tcpdump 'tcp[2:2]<=1023||udp[2:2]<=1023' -r BPFCheck.pcap | wc -l  
Answer: tcp[2:2]<=1023||udp[2:2]<=1023

Basic Analysis - HTTP. What is the Berkeley Packet Filter, using tcpdump, to capture all HTTP traffic? There should be 1404 packets
sudo tcpdump 'tcp[2:2]=80||tcp[0:2]=80' -r BPFCheck.pcap | wc -l 
Answer: tcp[2:2]=80||tcp[0:2]=80

Basic Analysis - TELNET. What is the Berkeley Packet Filter, using tcpdump, to capture all telnet traffic? There should be 62 packets
sudo tcpdump 'tcp[2:2]=23||tcp[0:2]=23' -r BPFCheck.pcap | wc -l
Answer: tcp[2:2]=23||tcp[0:2]=23

Basic Analysis - ARP. What is the Berkeley Packet Filter, using tcpdump, to capture all ARP traffic? There should be 40 packets
sudo tcpdump 'arp' -r BPFCheck.pcap | wc -l  (this works but is not the right answer)
sudo tcpdump 'ether[12:2] = 0x0806' -r BPFCheck.pcap | wc -l
Answer: ether[12:2]=0x0806

Basic Analysis - TOTAL CHAOS. What is the Berkeley Packet Filter, using tcpdump, to capture any packets containing the CHAOS protocol within an IPv4 header? There should be 139 packets
Need to figure out which protocol number CHAOS uses:
https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml#J_Noel_Chiappa
CHAOS = 16
sudo tcpdump 'ip[9] = 16' -r BPFCheck.pcap | wc -l
Answer: ip[9]=16

Basic Analysis - dscp. What is the Berkeley Packet Filter, using tcpdump, to capture all IPv4 packets with the DSCP field of 37? There should be 42 packets.
sudo tcpdump 'ip[1] >> 2 = 37'
ip[1] refers to the second byte (offset 1) in the IPv4 header, which contains the Type of Service (ToS) field that includes the DSCP bits.
>> 2 performs a right shift by 2 bits, which effectively discards the first 2 bits (precedence bits) of the ToS field, leaving only the DSCP bits.
= 37 checks if the resulting value is equal to 37, indicating that the DSCP field is set to 37.
Answer: ip[1]>>2=37

Basic Analysis - traceroute. What is the Berkeley Packet Filter, using tcpdump, to capture all IPv4 packets targeting just the beginning of potential traceroutes as it's entering your network. This can be from a Windows or Linux machine using their default settings? There should be 83 packets.
sudo tcpdump '(udp||icmp[0]=8)&&ip[8]=1' -r BPFCheck.pcap | wc -l (this works but doesn't count as correct)
ip[8] = 1 checks if the TTL field in the IP header is equal to 1.
(icmp[0] = 8 and ip[8] = 1) checks if the ICMP type field is equal to 8 (ICMP Echo Request) and the TTL field in the IP header is equal to 1.
udp captures all UDP packets.
(udp||icmp[0]=8)&&ip[8]=1
sudo tcpdump '(ip[9]=17||icmp[0]=8)&&ip[8]=1' -r BPFCheck.pcap | wc -l
sudo tcpdump '(ip[8]=1&ip[9]=1)||(ip[8]=1&ip[9]=17)' -r BPFCheck.pcap | wc -l
ip[9] refers to the tenth byte (offset 9) in the IP header, which contains the Protocol field.
= 17 checks if the Protocol field is equal to 17, which is the assigned value for UDP.
Answer: ????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????

Basic Analysis - URGent EXFIL. What is the Berkeley Packet Filter, using tcpdump, to capture all packets where the URG flag is not set and URG pointer has a value? There should be 43 packets
sudo tcpdump 'tcp[13] & 32 = 0 and tcp[18:2] != 0' -r BPFCheck.pcap | wc -l
tcp[13] refers to the fourteenth byte (offset 13) in the TCP header, which contains the TCP flags field.
& 32 performs a bitwise AND operation with the value 32 (binary 00100000) to check if the URG flag is not set. If the result is zero, it means the URG flag is not set.
tcp[18:2] refers to the nineteenth and twentieth bytes (offset 18 to 19) in the TCP header, which contain the URG pointer field.
!= 0 checks if the URG pointer field has a non-zero value.
Answer: tcp[13]&32=0&&tcp[18:2]!=0

Basic Analysis - NULL SCAN. What is the Berkeley Packet Filter, using tcpdump, to capture a TCP null scan to the host 10.10.10.10? There should be 19 packets
sudo tcpdump 'tcp[13] & 63 = 0 and dst host 10.10.10.10' -r BPFCheck.pcap | wc -l
tcp[13] refers to the fourteenth byte (offset 13) in the TCP header, which contains the TCP flags field.
& 63 performs a bitwise AND operation with the value 63 (binary 00111111) to check if no TCP flags are set. If the result is zero, it means no TCP flags are set, indicating a null scan.
dst host 10.10.10.10 specifies the destination IP address as 10.10.10.10.
sudo tcpdump 'tcp[13] & 63 = 0 and ip[16:4] = 0x0a0a0a0a' -r BPFCheck.pcap | wc -l (also works but this is wrong)
Answer: tcp[13]=0&&ip[16:4]=0x0a0a0a0a 

Basic Analysis - VLAN HOPPING. What is the Berkeley Packet Filter, using tcpdump, to capture an attacker using vlan hopping to move from vlan 1 to vlan 10? There should be 15 packets
ether[14:2] = 0x810a and (vlan or (ether[16:2] = 0x0001 and ether[18:2] = 0x000a))
ether[14:2] = 0x810a checks if the EtherType field of the Ethernet header is 0x810a, which represents a VLAN-tagged frame.
vlan checks for packets with VLAN tags.
(ether[16:2] = 0x0001 and ether[18:2] = 0x000a) checks if the source VLAN ID is 1 and the destination VLAN ID is 10.
sudo tcpdump 'ether[14:2] = 0x8100 and vlan and ether[18:2] = 0x8100
ether[14:2] = 0x8100 checks if the EtherType field of the Ethernet header is 0x8100, indicating the presence of the first VLAN tag.
vlan checks for packets with at least one VLAN tag.
ether[18:2] = 0x8100 checks if the EtherType field at an offset of 18 bytes in the Ethernet header is 0x8100, indicating the presence of the second VLAN tag.
20:22:48.381359 IP 192.168.0.1 > 255.255.255.255: ICMP echo request, id 0, seq 0, length 8 <-- this is definitely one of the packets that we want


Packet Crafting and Socket Creation
start flag: raw_packet_start

Senders:
DGRAM.py
#!/usr/bin/python3
import socket
s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, 0)
ip_addr = '127.0.0.1'
port = 4321
# Connect to a remote socket at address.
# s.connect((ip_addr, port)) # typically used for TCP
message = b"CCTC"
#Send data to the socket. The socket should not be connected to a remote socket. Typically used for UDP.
s.sendto (message, (ip_addr, port))
#Receive data from the socket. The return value is a pair (bytes, address) where bytes is a bytes object representing the data received$
data, addr = s.recvfrom(1024)
# You can optionally use s.recv but it will only return (bytes)
#Default encoding is 'utf-8'. errors may be given to set a different error handling scheme. The default for errors is 'strict', meaning$
print(data.decode())
# using "utf-8" default

RAW.py
#!/usr/bin/python3
# For building the socket
import socket
# For system level commands
import sys
# For establishing the packet structure (Used later on), this will allow direct access to the methods and functions in the struct module
from struct import *
# For encoding
import base64               # base64 module
import binascii            # binascii module
# Create a raw socket.
try:
    s = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_RAW)
except socket.error as msg:
    print(msg)
    sys.exit()
# 0 or IPPROTO_TCP for STREAM and 0 or IPPROTO_UDP for DGRAM. (man ip7). For SOCK_RAW you may specify a valid IANA IP protocol defined in RFC 1700 assigned numbers.
# IPPROTO_IP creates a socket that sends/receives raw data for IPv4-based protocols (TCP, UDP, etc). It will handle the IP headers for you, but you are responsible for processing/creating additional protocol data inside the IP payload.
# IPPROTO_RAW creates a socket that sends/receives raw data for any kind of protocol. It will not handle any headers for you, you are responsible for processing/creating all payload data, including IP and additional headers.(link)
packet = ''
src_ip = ""
dst_ip = ""
#######################
##Build Packet Header##
#######################
# Lets add the IPv4 header information
ip_ver_ihl = 69                         # This is putting the decimal conversion of 0x45 for Version and Internet Header Length
ip_tos = 0                             # This combines the DSCP and ECN feilds. Type of service/QoS
ip_len = 0                              # The kernel will fill in the actually length of the packet
ip_id = 0                            # This sets the IP Identification for the packet
ip_frag = 0                             # This sets fragmentation to off
ip_ttl = 1                             # This determines the TTL of the packet when leaving the machine
ip_proto = 6                           # This sets the IP protocol to 6 (TCP) so additional headers are required (reference IANA)
ip_check = 0                            # The kernel will fill in the checksum for the packet
ip_srcadd = socket.inet_aton(src_ip)    # inet_aton(string) will convert an IP address to a 32 bit binary number
ip_dstadd = socket.inet_aton(dst_ip)    # inet_aton(string) will convert an IP address to a 32 bit binary number
########################
## Pack the IP Header ##
########################
# This portion creates the header by packing the above variables into a structure. The ! in the string means 'Big-Endian' network order, while the code following specifies how to store the info. Endian explained. Refer to link for character meaning.
ip_header = pack('!BBHHHBBH4s4s' , ip_ver_ihl, ip_tos, ip_len, ip_id, ip_frag, ip_ttl, ip_proto, ip_check, ip_srcadd, ip_dstadd)
###########
##Message##
###########
# Your custom protocol fields or data. We are going to just insert data here. Add your message where the "?" is. Ensure you obfuscate it though...don't want any clear text messages being spotted! You can encode with various data encoding. Base64, binascii
message = b'last_name'                  #This should be the student's last name per the prompt
hidden_msg = binascii.hexlify(message)  #Students can choose which encoding they want to use.
#################
## Send Packet ##
#################
# final packet creation
packet = ip_header + hidden_msg
# Send the packet. Sendto is used when we do not already have a socket connected. Sendall or send if we do.
s.sendto(packet, (dst_ip, 0))
# socket.send is a low-level method and basically just the C/syscall method send(3) / send(2). It can send less bytes than you requested, but returns the number of bytes sent.
# socket.sendall is a high-level Python-only method that sends the entire buffer you pass or throws an exception. It does that by calling socket.send until everything has been sent or an error occurs.

STREAM.py
#!/usr/bin/python3
import socket
# create a socket
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)
# s = socket.socket() this is the same as above because we are using all defaults.
# use quotes ' ' to convert into a string
ip_addr = '127.0.0.1'
port = 1234
# connect is use to tell it to connect to the ((address, port))
# no quotes needed because its already a integer value
s.connect((ip_addr, port))
# send a string to the target - prefix b'message' to make a bytes-like object.
# Python3 does not like strings sent by itself
message = b"CCTC"
# = \n is for inline or send carriage return.
# Send the message to the target. The socket must be connected to a remote socket.
s.send(message)
# s = socket variable
# send = method
# (message) = the message variable
# Receive data from the socket.
# Split the return message into two variables. The return value is a pair (bytes(data), address(ip and port))
data, conn = s.recvfrom(1024)
# You can optionally use s.recv but it will only return (bytes)
# Default encoding is 'utf-8'. errors may be given to set a different error handling scheme.
# The default for errors is 'strict', meaning that encoding errors raise a UnicodeError.
# print the response from the receiver. UTF-8 is default. Others are UTF-16, UTF-32, ASCII, EBCIDIC
print(data.decode('utf-8'))
# close = function to close connection else it will hang
s.close()




TCP_RAW.py
#!/usr/bin/python3
# For building the socket
import socket
# For system level commands
import sys
# For doing an array in the TCP checksum
import array
# For establishing the packet structure (Used later on), this will allow direct access to the methods and functions in the struct module
from struct import *
# For encoding
import base64               # base64 module
import binascii            # binascii module
# Create a raw socket.
try:
    s = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_RAW)
except socket.error as msg:
    print(msg)
    sys.exit()
# 0 or IPPROTO_TCP for STREAM and 0 or IPPROTO_UDP for DGRAM. (man ip7). For SOCK_RAW you may specify a valid IANA IP protocol defined in RFC 1700 assigned numbers.
# IPPROTO_IP creates a socket that sends/receives raw data for IPv4-based protocols (TCP, UDP, etc). It will handle the IP headers for you, but you are responsible for processing/creating additional protocol data inside the IP payload.
# IPPROTO_RAW creates a socket that sends/receives raw data for any kind of protocol. It will not handle any headers for you, you are responsible for processing/creating all payload data, including IP and additional headers.(link)
packet = ''
src_ip = ""
dst_ip = ""
#######################
##Build Packet Header##
#######################
# Lets add the IPv4 header information
ip_ver_ihl = 69                         # This is putting the decimal conversion of 0x45 for Version and Internet Header Length
ip_tos = 0                             # This combines the DSCP and ECN fields. Type of service/QoS
ip_len = 0                              # The kernel will fill in the actually length of the packet
ip_id = 0                            # This sets the IP Identification for the packet
ip_frag = 0                             # This sets fragmentation to off
ip_ttl = 16                             # This determines the TTL of the packet when leaving the machine
ip_proto = 6                           # This sets the IP protocol to 6 (TCP) so additional headers are required (reference IANA)
ip_check = 0                            # The kernel will fill in the checksum for the packet
ip_srcadd = socket.inet_aton(src_ip)    # inet_aton(string) will convert an IP address to a 32 bit binary number
ip_dstadd = socket.inet_aton(dst_ip)    # inet_aton(string) will convert an IP address to a 32 bit binary number
########################
## Pack the IP Header ##
########################
# This portion creates the header by packing the above variables into a structure. The ! in the string means 'Big-Endian' network order, while the code following specifies how to store the info. Endian explained. Refer to link for character meaning.
ip_header = pack('!BBHHHBBH4s4s' , ip_ver_ihl, ip_tos, ip_len, ip_id, ip_frag, ip_ttl, ip_proto, ip_check, ip_srcadd, ip_dstadd)
####################
##Build TCP Header##
####################
tcp_src = 0                         # source port
tcp_dst = 0                          # destination port
tcp_seq = 0                        # sequence number
tcp_ack_seq = 0                     # tcp ack sequence number
tcp_data_off = 5                        # data offset specifying the size of tcp header * 4 which is 20
tcp_reserve = 0                         # the 3 reserve bits + ns flag in reserve field
tcp_flags = 0                           # tcp flags field before the bits are turned on
tcp_win = 65535                         # maximum allowed window size reordered to network order (socket.htons is deprecated)
tcp_chk = 0                             # tcp checksum which will be calculated later on
tcp_urg_ptr = 0                         # urgent pointer only if urg flag#!/usr/bin/python3
# For building the socket
import socket
# For system level commands
import sys
# For doing an array in the TCP checksum
import array
# For establishing the packet structure (Used later on), this will allow direct access to the methods and functions in the struct module
from struct import *
# For encoding
import base64               # base64 module
import binascii            # binascii module
# Create a raw socket.
try:
    s = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_RAW)
except socket.error as msg:
    print(msg)
    sys.exit()
# 0 or IPPROTO_TCP for STREAM and 0 or IPPROTO_UDP for DGRAM. (man ip7). For SOCK_RAW you may specify a valid IANA IP protocol defined in RFC 1700 assigned numbers.
# IPPROTO_IP creates a socket that sends/receives raw data for IPv4-based protocols (TCP, UDP, etc). It will handle the IP headers for you, but you are responsible for processing/creating additional protocol data inside the IP payload.
# IPPROTO_RAW creates a socket that sends/receives raw data for any kind of protocol. It will not handle any headers for you, you are responsible for processing/creating all payload data, including IP and additional headers.(link)
packet = ''
src_ip = ""
dst_ip = ""
#######################
##Build Packet Header##
#######################
# Lets add the IPv4 header information
ip_ver_ihl = 69                         # This is putting the decimal conversion of 0x45 for Version and Internet Header Length
ip_tos = 0                             # This combines the DSCP and ECN fields. Type of service/QoS
ip_len = 0                              # The kernel will fill in the actually length of the packet
ip_id = 0                            # This sets the IP Identification for the packet
ip_frag = 0                             # This sets fragmentation to off
ip_ttl = 16                             # This determines the TTL of the packet when leaving the machine
ip_proto = 6                           # This sets the IP protocol to 6 (TCP) so additional headers are required (reference IANA)
ip_check = 0                            # The kernel will fill in the checksum for the packet
ip_srcadd = socket.inet_aton(src_ip)    # inet_aton(string) will convert an IP address to a 32 bit binary number
ip_dstadd = socket.inet_aton(dst_ip)    # inet_aton(string) will convert an IP address to a 32 bit binary number
########################
## Pack the IP Header ##
########################
# This portion creates the header by packing the above variables into a structure. The ! in the string means 'Big-Endian' network order, while the code following specifies how to store the info. Endian explained. Refer to link for character meaning.
ip_header = pack('!BBHHHBBH4s4s' , ip_ver_ihl, ip_tos, ip_len, ip_id, ip_frag, ip_ttl, ip_proto, ip_check, ip_srcadd, ip_dstadd)
####################
##Build TCP Header##
####################
tcp_src = 0                         # source port
tcp_dst = 0                          # destination port
tcp_seq = 0                        # sequence number
tcp_ack_seq = 0                     # tcp ack sequence number
tcp_data_off = 5                        # data offset specifying the size of tcp header * 4 which is 20
tcp_reserve = 0                         # the 3 reserve bits + ns flag in reserve field
tcp_flags = 0                           # tcp flags field before the bits are turned on
tcp_win = 65535                         # maximum allowed window size reordered to network order (socket.htons is deprecated)
tcp_chk = 0                             # tcp checksum which will be calculated later on
tcp_urg_ptr = 0                         # urgent pointer only if urg flag is set
# Combine the left shifted 4 bit tcp offset and the reserve field
tcp_off_res = (tcp_data_off << 4) + tcp_reserve
# Tcp flags by bit starting from right to left
tcp_fin = 0                             # Finished
tcp_syn = 0                             # Synchronization
tcp_rst = 0                             # Reset
tcp_psh = 0                             # Push
tcp_ack = 0                             # Acknowledgment
tcp_urg = 0                             # Urgent
tcp_ece = 0                             # Explicit Congestion Notification Echo
tcp_cwr = 0                             # Congestion Window Reduced
# Combine the tcp flags by left shifting the bit locations and adding the bits together
tcp_flags = tcp_fin + (tcp_syn << 1) + (tcp_rst << 2) + (tcp_psh << 3) + (tcp_ack << 4) + (tcp_urg << 5) + (tcp_ece << 6) + (tcp_cwr << 7)
# The ! in the pack format string means network order
tcp_hdr = pack('!HHLLBBHHH', tcp_src, tcp_dst, tcp_seq, tcp_ack_seq, tcp_off_res, tcp_flags, tcp_win, tcp_chk, tcp_urg_ptr)
###########
##Message##
###########
# Your custom protocol fields or data. We are going to just insert data here. Add your message where the "?" is. Ensure you obfuscate it though...don't want any clear text messages being spotted! You can encode with various data encoding. Base64, binascii
message = b'last_name'                  #This should be the student's last name per the prompt
############################
##Create the Pseudo Header##
############################
# After you create the tcp header, create the pseudo header for the tcp checksum.
src_address = socket.inet_aton(src_ip)
dst_address = socket.inet_aton(dst_ip)
reserved = 0
protocol = socket.IPPROTO_TCP
tcp_length = len(tcp_hdr) + len(message)
##########################
##Pack the Pseudo Header##
##########################
ps_hdr = pack('!4s4sBBH', src_address, dst_address, reserved, protocol, tcp_length)
ps_hdr = ps_hdr + tcp_hdr + message
################################
##Define the Checksum Function##
################################
def checksum(data):
        if len(data) % 2 != 0:
                data += b'\0'
        res = sum(array.array("H", data))
        res = (res >> 16) + (res & 0xffff)
        res += res >> 16
        return (~res) & 0xffff
tcp_chk = checksum(ps_hdr)
##################
##Final TCP Pack##
##################
# Pack the tcp header to fill in the correct checksum - remember checksum is NOT in network byte order
tcp_hdr = pack('!HHLLBBH', tcp_src, tcp_dst, tcp_seq, tcp_ack_seq, tcp_off_res, tcp_flags, tcp_win) + pack('H', tcp_chk) + pack('!H', tcp_urg_ptr)
#################
## Send Packet ##
#################
# Combine all of the headers and the user data
packet = ip_header + tcp_hdr + message
# Send the packet. Sendto is used when we do not already have a socket connected. Sendall or send if we do.
s.sendto(packet, (dst_ip, 0))
# socket.send is a low-level method and basically just the C/syscall method send(3) / send(2). It can send less bytes than you requested, but returns the number of bytes sent.
# socket.sendall is a high-level Python-only method that sends the entire buffer you pass or throws an exception. It does that by calling socket.send until everything has been sent or an error occurs. is set
# Combine the left shifted 4 bit tcp offset and the reserve field
tcp_off_res = (tcp_data_off << 4) + tcp_reserve
# Tcp flags by bit starting from right to left
tcp_fin = 0                             # Finished
tcp_syn = 0                             # Synchronization
tcp_rst = 0                             # Reset
tcp_psh = 0                             # Push
tcp_ack = 0                             # Acknowledgment
tcp_urg = 0                             # Urgent
tcp_ece = 0                             # Explicit Congestion Notification Echo
tcp_cwr = 0                             # Congestion Window Reduced
# Combine the tcp flags by left shifting the bit locations and adding the bits together
tcp_flags = tcp_fin + (tcp_syn << 1) + (tcp_rst << 2) + (tcp_psh << 3) + (tcp_ack << 4) + (tcp_urg << 5) + (tcp_ece << 6) + (tcp_cwr << 7)
# The ! in the pack format string means network order
tcp_hdr = pack('!HHLLBBHHH', tcp_src, tcp_dst, tcp_seq, tcp_ack_seq, tcp_off_res, tcp_flags, tcp_win, tcp_chk, tcp_urg_ptr)
###########
##Message##
###########
# Your custom protocol fields or data. We are going to just insert data here. Add your message where the "?" is. Ensure you obfuscate it though...don't want any clear text messages being spotted! You can encode with various data encoding. Base64, binascii
message = b'last_name'                  #This should be the student's last name per the prompt
############################
##Create the Pseudo Header##
############################
# After you create the tcp header, create the pseudo header for the tcp checksum.
src_address = socket.inet_aton(src_ip)
dst_address = socket.inet_aton(dst_ip)
reserved = 0
protocol = socket.IPPROTO_TCP
tcp_length = len(tcp_hdr) + len(message)
##########################
##Pack the Pseudo Header##
##########################
ps_hdr = pack('!4s4sBBH', src_address, dst_address, reserved, protocol, tcp_length)
ps_hdr = ps_hdr + tcp_hdr + message
################################
##Define the Checksum Function##
################################
def checksum(data):
        if len(data) % 2 != 0:
                data += b'\0'
        res = sum(array.array("H", data))
        res = (res >> 16) + (res & 0xffff)
        res += res >> 16
        return (~res) & 0xffff
tcp_chk = checksum(ps_hdr)
##################
##Final TCP Pack##
##################
# Pack the tcp header to fill in the correct checksum - remember checksum is NOT in network byte order
tcp_hdr = pack('!HHLLBBH', tcp_src, tcp_dst, tcp_seq, tcp_ack_seq, tcp_off_res, tcp_flags, tcp_win) + pack('H', tcp_chk) + pack('!H', tcp_urg_ptr)
#################
## Send Packet ##
#################
# Combine all of the headers and the user data
packet = ip_header + tcp_hdr + message
# Send the packet. Sendto is used when we do not already have a socket connected. Sendall or send if we do.
s.sendto(packet, (dst_ip, 0))
# socket.send is a low-level method and basically just the C/syscall method send(3) / send(2). It can send less bytes than you requested, but returns the number of bytes sent.
# socket.sendall is a high-level Python-only method that sends the entire buffer you pass or throws an exception. It does that by calling socket.send until everything has been sent or an error occurs.

AddressFamilies. Level I Challenge
What are the 3 Address Families associated with the python3 socket module?
example: socket.ADDFAM, socket.ADDFAM, socket.ADDFAM
Answer: socket.AF_UNIX, socket.AF_INET, socket.AF_INET6

Connections. Level I Challenge
What are the two socket functions called to open a connection and to disconnect from that connection?
example: socket.fun(), socket.func()
Answer: socket.connect(), socket.close()

Header Preparation. Level I Challenge
What python3 library function is utilized to combine the various pieces of your raw socket packet into network order?
example: module.function
Answer: struct.pack

Missing Data. What must be manually created with raw sockets that stream and datagram sockets creates for you?
Answer: header

Sending UDP. What function within the socket module allows you to Send data to a socket, while not already being connected to a remote socket?
example: socket.func()Objects
5
Level I Challenge

When sending data across a connection, what must a string be converted to before being sent due to encoding?

Answer: socket.sendto()

Transport Layer Sockets. Provide an example of the two required items needed to be set in order to send a Datagram or Stream socket? (excluding any of the socket.socket functions)
example: item1 item2
Answer: ip address port

Objects. When sending data across a connection, what must a string be converted to before being sent due to encoding?
Answer: bytes-like object

Gorgas Socket Manipulation (GPM)
XX OCT 2023
Start Time: 1300
Duration: 4 hours

Type of Operation: Socket Programming for Datagram, IP, TCP

Objective: Gorgas Cyber Forces are preparing for an upcoming mission and have requested assistance with packet manipulation. They need to send custom message to allied forces throughout the region; however, they currently do not have anyone available that understands how. Using Python your team is required to complete each of the following tasks (Specific details for each task are identified in the challenge):

    Utilize sockets and craft a custom Raw IPv4 Sockets

    Utilize sockets and craft a custom Raw IPv4 TCP Sockets

    Utilize sockets and craft a custom Datagram Socket Message Sender

    Utilize sockets and craft a custom Stream Socket Message Sender

Click Here to view there current progress on the scripts

Tools/Techniques: Python3, Wireshark/TCPDump

Scenario Credentials: FLAG = raw_packet_start

Prior Approvals: Prior to completing each of the four tasks, ensure you understand the various items of the script you developed.

Scheme of Maneuver:
> Linux Workstations:
→ T1: INTERNET_HOST
-→ T2: BLUE_DMZ_Host

Target Section:

T1
Hostname: INTERNET_HOST
IP: PROVIDED FLOAT IP
OS: Linux
Creds: PROVIDED CREDENTIALS
Last Known SSH Port: 22
PSP: none
Malware: none
Action: Send a Datagram Socket Message to this host

T2
Hostname: BLUE_DMZ_Host-1
IP: 172.16.1.15
OS: unknown
Creds:unknown
Last Known SSH Port: unknown
PSP: Unknown
Malware: Unknown
Action: Send a Stream Socket Message to this host


Stream Socket Message Sender. Gorgan Forces have requested you get a message to one of their remote teams that are utilizing the BLUE_DMZ_HOST-1. Utilizing the criteria they provided, generate a stream socket with python3:
Coded information was placed into the video below. Look at the note the woman passes to the man.
https://youtu.be/6WTdTwcmxyo?t=35
    From your INTERNET-HOST to the BLUE_DMZ_HOST-1
    Port number = #Last four digits on the note
    Message = #Name on the note (First letter capitalized)
STREAM_v1.py
#!/usr/bin/python3
import socket
# create a socket
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)
# s = socket.socket() this is the same as above because we are using all defaults.
# use quotes ' ' to convert into a string
ip_addr = '172.16.1.15'
port = 5309
# connect is use to tell it to connect to the ((address, port))
# no quotes needed because its already a integer value
s.connect((ip_addr, port))
# send a string to the target - prefix b'message' to make a bytes-like object.
# Python3 does not like strings sent by itself
message = b"Jenny"
# = \n is for inline or send carriage return.
# Send the message to the target. The socket must be connected to a remote socket.
s.send(message)
# s = socket variable
# send = method
# (message) = the message variable
# Receive data from the socket.
# Split the return message into two variables. The return value is a pair (bytes(data), address(ip and port))
data, conn = s.recvfrom(1024)
# You can optionally use s.recv but it will only return (bytes)
# Default encoding is 'utf-8'. errors may be given to set a different error handling scheme.
# The default for errors is 'strict', meaning that encoding errors raise a UnicodeError.
# print the response from the receiver. UTF-8 is default. Others are UTF-16, UTF-32, ASCII, EBCIDIC
print(data.decode('utf-8'))
# close = function to close connection else it will hang
s.close()

Datagram Socket Message Sender. Gorgan Forces have requested you get a message to one of their remote teams that are utilizing the INTERNET_HOST. Utilizing the criteria they provided, generate a datagram socket with python3:
Coded information was placed into the video below. Listen to the words in the video.
https://youtu.be/OuK4OcMUGcg?t=67
    Send to your INTERNET-HOST localhost.
    Port number = #The number of fists
    Message = #The name of the band (First letter capitalized)
Message = Disturbed
port  = 10000

DGRAM_v1.py
#!/usr/bin/python3
import socket
s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, 0)
ip_addr = '127.0.0.1'
port = 10000
# Connect to a remote socket at address.
# s.connect((ip_addr, port)) # typically used for TCP
message = b"Disturbed"
#Send data to the socket. The socket should not be connected to a remote socket. Typically used for UDP.
s.sendto (message, (ip_addr, port))
#Receive data from the socket. The return value is a pair (bytes, address) where bytes is a bytes object representing the data received$
data, addr = s.recvfrom(1024)
# You can optionally use s.recv but it will only return (bytes)
#Default encoding is 'utf-8'. errors may be given to set a different error handling scheme. The default for errors is 'strict', meaning$
print(data.decode())
# using "utf-8" default

Raw IPv4 Socket. Gorgan forces, tool development cell have provided RAWSOCK.py for your teams use, it defines the basic structure of the desired result.
    Create a raw socket and code your message into the socket
    Send your last name as the data.
    The sent data is required to be encoded, with a final result of the data being in hex. You can use the python module of your choice; a good module to start with is binascii.
    When viewing in Wireshark, the packet should not be malformed
Target IP: 172.16.1.15
TOS: 96
IP ID: 1984
Protocol: CHAOS
The flag will be provided by the Mission Command once you complete the activity.
    Provide the Wireshark Packet Capture.
    Provide proof of the decoded message.
RAW.py
#!/usr/bin/python3
import socket
import sys
from struct import *
import base64               # base64 module
import binascii            # binascii module
try:
    s = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_RAW)
except socket.error as msg:RAW.py
#!/usr/bin/python3
import socket
import sys
from struct import *
import base64               # base64 module
import binascii            # binascii module
try:
    s = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_RAW)
except socket.error as msg:
    print(msg)
    sys.exit()
packet = ''
src_ip = "10.10.0.40"
dst_ip = "172.16.1.15"
ip_ver_ihl = 69                         # This is putting the decimal conversion of 0x45 for Version and Internet Header Length
ip_tos = 96                             # This combines the DSCP and ECN feilds. Type of service/QoS
ip_len = 0                              # The kernel will fill in the actually length of the packet
ip_id = 1984                            # This sets the IP Identification for the packet
ip_frag = 0                             # This sets fragmentation to off
ip_ttl = 1                             # This determines the TTL of the packet when leaving the machine
ip_proto = 16                           # This sets the IP protocol to 6 (TCP) so additional headers are required (reference IANA)
ip_check = 0                            # The kernel will fill in the checksum for the packet
ip_srcadd = socket.inet_aton(src_ip)    # inet_aton(string) will convert an IP address to a 32 bit binary number
ip_dstadd = socket.inet_aton(dst_ip)    # inet_aton(string) will convert an IP address to a 32 bit binary number
ip_header = pack('!BBHHHBBH4s4s' , ip_ver_ihl, ip_tos, ip_len, ip_id, ip_frag, ip_ttl, ip_proto, ip_check, ip_srcadd, ip_dstadd)
message = b'last_name'                  #This should be the student's last name per the prompt
hidden_msg = binascii.hexlify(message)  #Students can choose which encoding they want to use.
packet = ip_header + hidden_msg
s.sendto(packet, (dst_ip, 0))
    print(msg)
    sys.exit()
packet = ''
src_ip = "10.10.0.40"
dst_ip = "172.16.1.15"
ip_ver_ihl = 69                         # This is putting the decimal conversion of 0x45 for Version and Internet Header Length
ip_tos = 96                             # This combines the DSCP and ECN feilds. Type of service/QoS
ip_len = 0                              # The kernel will fill in the actually length of the packet
ip_id = 1984                            # This sets the IP Identification for the packet
ip_frag = 0                             # This sets fragmentation to off
ip_ttl = 1                             # This determines the TTL of the packet when leaving the machine
ip_proto = 16                           # This sets the IP protocol to 6 (TCP) so additional headers are required (reference IANA)
ip_check = 0                            # The kernel will fill in the checksum for the packet
ip_srcadd = socket.inet_aton(src_ip)    # inet_aton(string) will convert an IP address to a 32 bit binary number
ip_dstadd = socket.inet_aton(dst_ip)    # inet_aton(string) will convert an IP address to a 32 bit binary number
ip_header = pack('!BBHHHBBH4s4s' , ip_ver_ihl, ip_tos, ip_len, ip_id, ip_frag, ip_ttl, ip_proto, ip_check, ip_srcadd, ip_dstadd)
message = b'last_name'                  #This should be the student's last name per the prompt
hidden_msg = binascii.hexlify(message)  #Students can choose which encoding they want to use.
packet = ip_header + hidden_msg
s.sendto(packet, (dst_ip, 0))








